<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>–Ü–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞ —Ç–∞–±–ª–∏—Ü—è ‚Äî –±–∞–ª–∞–Ω—Å —Ä–µ–∞–∫—Ü—ñ—ó + –≤–µ–∫—Ç–æ—Ä–∏ (fixed layout)</title>

<style>
  :root{ --accent:#2a9df4; --pos:#1e6ed1; --neg:#e85d5d; --border:#9aa; --bg-react:#eef7ff; --bg-prod:#fff3f3; }
  /* Box sizing reset to avoid unexpected overflow */
  *, *::before, *::after { box-sizing: border-box; }

  body{background:#f6f9fc; margin:0; padding:0; font-family:Arial, sans-serif; color:#222;}
  .chem-wrap{ max-width:1200px; width:calc(100% - 32px); margin:24px auto; background:#fff; padding:16px; border-radius:12px; box-shadow:0 2px 6px rgba(0,0,0,0.08); overflow:hidden; }
  .title{text-align:center; font-weight:700; margin-bottom:6px; font-size:20px;}
  .eq{ text-align:center; margin-bottom:12px; font-size:18px;}
  .formula-box{display:flex; gap:8px; justify-content:center; flex-wrap:wrap; align-items:center; margin-bottom:8px;}
  .formula-part{display:inline-flex; align-items:center; gap:6px; font-weight:600;}
  .controls-row{display:flex; gap:12px; align-items:center; justify-content:center; margin-bottom:12px; flex-wrap:wrap;}
  .layout{ display:grid; grid-template-columns: 1fr minmax(320px, 520px); gap:16px; align-items:start; }
  @media (max-width:1100px){ .layout{grid-template-columns:1fr;} }
  table.chem{border-collapse:collapse; width:100%;}
  table.chem caption{caption-side:top; font-weight:700; margin-bottom:8px; text-align:left;}
  table.chem th, table.chem td{border:1px solid var(--border); padding:6px; text-align:center; min-width:46px; background:#fff; vertical-align:middle;}
  table.chem th{background:#e6f0fb; font-weight:700;}
  .elem-cell{background:#fafafa; font-weight:600;}
  input.num{width:100%; border:0; text-align:center; font-size:14px; padding:4px; background:transparent;}
  input.num:focus{outline:1px solid var(--accent); background:#eef7ff;}
  .coef{width:56px; padding:6px; text-align:center; border-radius:6px; border:1px solid #d7eafb; background:#f8fbff;}
  .coef-row th{background:#f4f8ff;}
  .mol-header{display:flex; flex-direction:column; gap:6px; align-items:center; justify-content:center;}
  .mol-name{font-weight:700; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:100px;}
  .mol-name.reactant{ color: var(--pos); }
  .mol-name.product{ color: var(--neg); }
  .group-reactants{ background: linear-gradient(180deg,var(--bg-react),#f7fbff); color:var(--pos); }
  .group-products{ background: linear-gradient(180deg,var(--bg-prod),#fff7f7); color:var(--neg); }
  .rp-cell{min-height:36px; min-width:64px; display:flex; align-items:center; justify-content:center; background:#fff; transition:color 0.15s, background 0.15s;}
  .rp-zero{color:#333;}
  .rp-pos{color:var(--pos); font-weight:700;}
  .rp-neg{color:var(--neg); font-weight:700;}
  .note{font-size:13px; color:#555; text-align:center; margin-top:8px;}
  .mol-fallback{opacity:0.7; font-style:italic;}
  .rp-header{ white-space:nowrap; vertical-align:middle; }

  .vector-panel{ background:#fff; border:1px solid #e2eefc; border-radius:10px; padding:8px; max-width:100%; overflow:hidden; }
  .vector-title{font-weight:700; font-size:15px; margin-bottom:8px; text-align:center;}
  .vector-svg{ width:100%; height:auto; display:block; background:linear-gradient(180deg,#fbfeff,#f7fbff); border-radius:8px; border:1px solid #e6f7ff; max-width:100%; overflow:hidden; }

  .axis-labels{display:flex; justify-content:space-between; align-items:center; gap:8px; padding:0 6px 6px 6px; margin-bottom:6px;}
  .axis-labels .axis-box{display:flex; flex-direction:column; align-items:center;}
  .axis-labels .axis-box .axis-title{font-weight:700; font-size:12px; color:#334;}
  .axis-labels .y-label{ font-weight:700; color:#1e6ed1; } /* —Å–∏–Ω—è –¥–ª—è —Ä–µ–∞–∫—Ç–∞–Ω—Ç—ñ–≤ */
  .axis-labels .x-label{ font-weight:700; color:#e85d5d; } /* —á–µ—Ä–≤–æ–Ω–∞ –¥–ª—è –ø—Ä–æ–¥—É–∫—Ç—ñ–≤ */
  .vector-legend{font-size:13px; margin-top:8px; color:#444; text-align:left;}
  .method-def{font-size:13px; margin-top:10px; color:#333; background:#fbfdff; padding:8px; border-radius:6px; border:1px solid #eef6ff;}
  .method-def b{color:#112;}
  .axis-selectors{display:flex; gap:8px; justify-content:center; align-items:center; margin-bottom:8px; flex-wrap:wrap;}
  .order-selectors{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}

  .mapping-note-inline{font-size:14px; color:#2b4758; margin-top:8px; padding:6px 8px; background:#f7fbff; border-radius:6px; border:1px solid #e1f0ff; text-align:left; white-space:normal; line-height:1.3;}
  @media (max-width:880px){ .coef{width:48px;} table.chem th, table.chem td{font-size:13px; padding:6px;} .formula-box{font-size:15px;} }

  .svg-axis-label { font-family: Arial, sans-serif; font-size:11px; fill:#246; }
  .svg-tick { stroke:#79a9d9; stroke-width:1; }

  .legend-inline{display:flex; gap:10px; align-items:center; font-size:13px;}
  .legend-dot{width:12px; height:12px; border-radius:6px; display:inline-block; margin-right:6px;}
  .legend-react{ background:#5da0e8; }
  .legend-prod{ background:#e85d5d; }

  .parse-panel { display:flex; gap:10px; align-items:flex-start; justify-content:center; margin-bottom:12px; flex-wrap:wrap; }
  .parse-panel textarea { width:520px; min-height:56px; padding:8px; border-radius:6px; border:1px solid #d7eafb; resize:vertical; background:#fbfeff; }
  .parse-panel button { padding:8px 10px; border-radius:6px; background:var(--accent); color:#fff; border:0; cursor:pointer; }
</style>
</head>
<body>

<div class="chem-wrap">
  <div class="title">–Ü–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞ —Ç–∞–±–ª–∏—Ü—è ‚Äî –±–∞–ª–∞–Ω—Å —Ä–µ–∞–∫—Ü—ñ—ó + –≤–µ–∫—Ç–æ—Ä–∏</div>

  <!-- NEW: parser input panel -->
  <div class="parse-panel" aria-label="Load balanced equation">
    <div style="font-size:13px; color:#444; align-self:center;"><b>–í—Å—Ç–∞–≤—Ç–µ –∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–µ —Ä—ñ–≤–Ω—è–Ω–Ω—è (–æ–¥–Ω–∞ —Ä–µ–∞–∫—Ü—ñ—è):</b></div>
    <textarea id="parsedInput" placeholder="–ù–∞–ø—Ä.: 2 H2 + O2 = 2 H2O"></textarea>
    <div style="display:flex; flex-direction:column; gap:8px;">
      <button id="loadParsedBtn" type="button">Load & Visualize</button>
      <button id="clearParsedBtn" type="button" style="background:#999;">Clear</button>
    </div>
  </div>
  <!-- END NEW -->

  <div class="eq" aria-live="polite">
    <div class="formula-box" id="equation"></div>
    <div style="font-size:13px; color:#444;">(–†–µ–∞–∫—Ç–∞–Ω—Ç–∏ –∑–ª—ñ–≤–∞ ‚Äî –ü—Ä–æ–¥—É–∫—Ç–∏ —Å–ø—Ä–∞–≤–∞)</div>
  </div>

  <div class="controls-row">
    <div style="font-size:13px; color:#444;">–û–±–µ—Ä—ñ—Ç—å –æ—Å—ñ –¥–ª—è –≤–µ–∫—Ç–æ—Ä—ñ–≤ (X, Y):</div>
    <div class="axis-selectors" id="axisSelectors"></div>

    <div class="order-selectors" id="orderSelectors" style="margin-left:8px;">
      <label style="font-size:13px;color:#333;">–ü–æ—Ä—è–¥–æ–∫ R:</label>
      <select id="orderR" style="padding:4px;font-size:13px;">
        <option value="auto">auto (‚Üë by size)</option>
        <option value="asc">asc (by size)</option>
        <option value="desc">desc (by size)</option>
        <option value="none">none (as is)</option>
      </select>
      <label style="font-size:13px;color:#333;">–ü–æ—Ä—è–¥–æ–∫ P:</label>
      <select id="orderP" style="padding:4px;font-size:13px;">
        <option value="auto">auto (‚Üì by size)</option>
        <option value="asc">asc (by size)</option>
        <option value="desc">desc (by size)</option>
        <option value="none">none (as is)</option>
      </select>
    </div>
  </div>

  <div class="layout">
    <div>
      <table class="chem" id="mainTable" aria-label="–¢–∞–±–ª–∏—Ü—è –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ —ñ –º–æ–ª–µ–∫—É–ª">
        <caption>–¢–∞–±–ª–∏—Ü—è –∞—Ç–æ–º–Ω–∏—Ö —ñ–Ω–¥–µ–∫—Å—ñ–≤ (—Ä–µ–∞–∫—Ç–∞–Ω—Ç–∏ ‚Äî –ª—ñ–≤–æ—Ä—É—á, –ø—Ä–æ–¥—É–∫—Ç–∏ ‚Äî –ø—Ä–∞–≤–æ—Ä—É—á). –ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ –≤–∏–Ω–µ—Å–µ–Ω—ñ –æ–∫—Ä–µ–º–∏–º –ø–æ–ª–µ–º.</caption>
        <thead>
          <tr>
            <th scope="col" rowspan="3">–ï–ª–µ–º–µ–Ω—Ç</th>
            <th scope="col" rowspan="3">X</th>
            <th scope="col" rowspan="3">Y</th>
            <th scope="col" colspan="3" class="group-reactants">–†–µ–∞–∫—Ç–∞–Ω—Ç–∏</th>
            <th scope="col" rowspan="3" class="rp-header">R ‚àí P</th>
            <th scope="col" colspan="5" class="group-products">–ü—Ä–æ–¥—É–∫—Ç–∏</th>
          </tr>
          <tr id="moleculeNames"></tr>
          <tr id="moleculeCoefs" class="coef-row"></tr>
        </thead>
        <tbody id="elementsBody"></tbody>
      </table>

      <div class="note">–ó–º—ñ–Ω—é–π —á–∏—Å–ª–∞ —ñ–Ω–¥–µ–∫—Å—ñ–≤ –∞–±–æ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ ‚Äî —Ä—ñ–≤–Ω—è–Ω–Ω—è, —Ä—ñ–∑–Ω–∏—Ü—è (R ‚àí P) —Ç–∞ –≤–µ–∫—Ç–æ—Ä–∏ –æ–Ω–æ–≤–ª—é—é—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ.</div>
    </div>

    <div class="vector-panel" aria-label="–ü–∞–Ω–µ–ª—å –≤–µ–∫—Ç–æ—Ä—ñ–≤">
      <div class="vector-title">–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω–∞ —Å—ñ—Ç–∫–∞ ‚Äî –≤–µ–∫—Ç–æ—Ä–Ω—ñ —à–ª—è—Ö–∏ —Ä–µ–∞–∫—Ç–∞–Ω—Ç—ñ–≤ —ñ –ø—Ä–æ–¥—É–∫—Ç—ñ–≤</div>

      <div class="axis-labels" aria-hidden="false">
        <div class="axis-box"><div class="axis-title">Y (–≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞) ‚Äî –†–µ–∞–∫—Ç–∞–Ω—Ç–∏ üîµ</div><div class="y-label" id="axisLabelY">Y:</div></div>
        <div class="axis-box"><div class="axis-title">X (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞) ‚Äî –ü—Ä–æ–¥—É–∫—Ç–∏ üî¥</div><div class="x-label" id="axisLabelX">X:</div></div>
      </div>

      <svg id="vectorSvg" class="vector-svg" viewBox="0 0 520 520" preserveAspectRatio="xMidYMid meet" role="img" aria-label="–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω–∞ —Å—ñ—Ç–∫–∞"></svg>

      <div style="margin-top:8px;">
        <div class="legend-inline"><span class="legend-dot legend-react"></span>–†–µ–∞–∫—Ç–∏–≤–Ω–∏–π —à–ª—è—Ö (R)</div>
        <div class="legend-inline" style="margin-top:4px;"><span class="legend-dot legend-prod"></span>–ü—Ä–æ–¥—É–∫—Ç–æ–≤–∏–π —à–ª—è—Ö (P)</div>
      </div>
    </div>
  </div>

  <div style="margin-top:12px;">
    <div class="vector-legend" id="vectorLegend">
      –¢–µ–ø–µ—Ä –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –ø–æ–∫–∞–∑—É—î –¥–≤–∞ –∫—É–º—É–ª—è—Ç–∏–≤–Ω—ñ —à–ª—è—Ö–∏: –æ–¥–∏–Ω –¥–ª—è —Ä–µ–∞–∫—Ç–∞–Ω—Ç—ñ–≤ (—Å–∏–Ω—ñ–π, R), —ñ–Ω—à–∏–π –¥–ª—è –ø—Ä–æ–¥—É–∫—Ç—ñ–≤ (—á–µ—Ä–≤–æ–Ω–∏–π, P).
    </div>

    <div class="method-def" id="methodDef" aria-live="polite" style="margin-top:10px;">
      <b>–§–æ—Ä–º–∞–ª—å–Ω—ñ –ø—Ä–∞–≤–∏–ª–∞ (–º—ñ–∫—Ä–æ‚Äë—Å–ø—Ä–∞–≤–∫–∞ –º–µ—Ç–æ–¥—É):</b>
      <ol>
        <li><b>–í–µ–∫—Ç–æ—Ä –º–æ–ª–µ–∫—É–ª–∏</b>: v = (n‚Çì, n·µß), –¥–µ n‚Çì,n·µß ‚Äî –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –∞—Ç–æ–º—ñ–≤ –≤–∏–±—Ä–∞–Ω–∏—Ö –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ —É –º–æ–ª–µ–∫—É–ª—ñ. –ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç k –º–Ω–æ–∂–∏—Ç—å –≤–µ–∫—Ç–æ—Ä.</li>
        <li><b>–®–ª—è—Ö</b>: —à–ª—è—Ö —Å—É–º—ñ—à—ñ = –≤–ø–æ—Ä—è–¥–∫–æ–≤–∞–Ω–∞ (–ø–æ—Å–ª—ñ–¥–æ–≤–Ω–∞) —Å—É–º–∞ –≤–µ–∫—Ç–æ—Ä—ñ–≤ –º–æ–ª–µ–∫—É–ª (–∫–æ–∂–Ω–∞ –º–æ–ª–µ–∫—É–ª–∞ ‚Äî –æ–∫—Ä–µ–º–∏–π —Å–µ–≥–º–µ–Ω—Ç).</li>
        <li><b>–ü–æ—á–∞—Ç–∫–æ–≤–∞ —Ç–æ—á–∫–∞</b>: –æ–±–∏–¥–≤–∞ —à–ª—è—Ö–∏ –ø–æ—á–∏–Ω–∞—é—Ç—å—Å—è –∑ (0,0).</li>
        <li><b>–ë–∞–ª–∞–Ω—Å</b>: —Ä–µ–∞–∫—Ü—ñ—è –∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–∞ ‚áî –≤–µ–∫—Ç–æ—Ä–Ω–∞ —Å—É–º–∞ —Ä–µ–∞–∫—Ç–∞–Ω—Ç—ñ–≤ = –≤–µ–∫—Ç–æ—Ä–Ω–∞ —Å—É–º–∞ –ø—Ä–æ–¥—É–∫—Ç—ñ–≤ (–∫—ñ–Ω—Ü–µ–≤—ñ —Ç–æ—á–∫–∏ —à–ª—è—Ö—É —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å).</li>
        <li><b>–ü—Ä–æ—î–∫—Ü—ñ—è</b>: –≤–∏–±—ñ—Ä –æ—Å–µ–π X,Y ‚Äî –ø—Ä–æ—î–∫—Ü—ñ—è –±–∞–≥–∞—Ç–æ–≤–∏–º—ñ—Ä–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å—É –Ω–∞ –ø–ª–æ—â–∏–Ω—É; –∑–±—ñ–≥ —É 2D –Ω–µ –≥–∞—Ä–∞–Ω—Ç—É—î –ø–æ–≤–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å—É —É –≤—Å—ñ—Ö –µ–ª–µ–º–µ–Ω—Ç–∞—Ö.</li>
        <li><b>–ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏</b>: —Å—Ç–µ—Ö—ñ–æ–º–µ—Ç—Ä–∏—á–Ω—ñ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ ‚Äî —Ü—ñ–ª—ñ –Ω–µ–≤—ñ–¥ º—î–º–Ω—ñ —á–∏—Å–ª–∞ (‚Ñï‚ÇÄ). –Ü–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∑–∞–±–µ–∑–ø–µ—á—É—î —Ü—é —É–º–æ–≤—É.</li>
      </ol>
    </div>

    <div class="mapping-note-inline" id="mappingNote" aria-hidden="false" style="margin-top:8px;"></div>
  </div>

  <div class="composition-legend" style="background:#f7fbff; border:1px solid #e1f0ff; border-radius:8px; padding:12px; margin-top:12px;">
    <div style="font-weight:700; font-size:14px; margin-bottom:8px;">üìã –°–∫–ª–∞–¥ —Ä–µ–∞–∫—Ç–∞–Ω—Ç—ñ–≤ —Ç–∞ –ø—Ä–æ–¥—É–∫—Ç—ñ–≤: </div>
    <div style="display:flex; gap:20px;">
      <div>
        <div style="color:#1e6ed1; font-weight:700; margin-bottom:4px;">üîµ –†–µ–∞–∫—Ç–∞–Ω—Ç–∏ (R):</div>
        <div style="color:#445; font-size:13px; line-height:1.6;" id="compR">
          ‚Ä¢ H‚ÇÇO (H:  2, O: 1)<br>
          ‚Ä¢ CO‚ÇÇ (C: 1, O: 2)<br>
          ‚Ä¢ O‚ÇÇ (O: 2)
        </div>
      </div>
      <div>
        <div style="color:#e85d5d; font-weight:700; margin-bottom:4px;">üî¥ –ü—Ä–æ–¥—É–∫—Ç–∏ (P):</div>
        <div style="color:#445; font-size:13px; line-height:1.6;" id="compP">
          ‚Ä¢ H‚ÇÇ (H: 2)<br>
          ‚Ä¢ O‚ÇÉ (O: 3)<br>
          ‚Ä¢ H‚ÇÇCO‚ÇÉ (H: 2, C: 1, O:  3)<br>
          ‚Ä¢ N‚ÇÇ (N: 2)<br>
          ‚Ä¢ NH‚ÇÉ (N: 1, H: 3)
        </div>
      </div>
    </div>
  </div>

</div>

<!-- include parser and balancer (the files you provided) -->
<script src="chem_parser.js"></script>
<script src="chem_balancer.js"></script>

<script>
document.addEventListener("DOMContentLoaded", () => {
  // NOTE: the main visualiser code is preserved (kept identical to your original),
  // but we add a small integration function parseAndLoadEquation() that re-constructs
  // the table from a single parsed/balanced equation returned by the predictor's parser.

  // --- existing data (defaults) ---
  let elements = ["H","C","O","N","P","S","F","Na","Ca"];
  let reactants = [
    {id:"h2o", label:"H2O"},
    {id:"co2", label:"CO2"},
    {id:"o2",  label:"O2"}
  ];
  let products = [
    {id:"h2",   label:"H2"},
    {id:"o3",   label:"O3"},
    {id:"h2co3",label:"H2CO3"},
    {id:"n2",   label:"N2"},
    {id:"nh3",  label:"NH3"}
  ];

  const MAX_COEF = 100;
  const MIN_AXIS_SPAN = 10;
  const VISUAL_OFFSET_PX = 2;
  const STORAGE_KEY = 'chem_balancer_state_v1';
  // defaultIndexMap will be rebuilt when loading parsed equation
  let defaultIndexMap = {
    h2o: {H:2,O:1},
    co2: {C:1,O:2},
    o2:  {O:2},
    h2:  {H:2},
    o3:  {O:3},
    h2co3:{H:2,C:1,O:3},
    n2:  {N:2},
    nh3: {N:1,H:3}
  };
  const warnedMissingMol = new Set();

  // helper q/qAll
  function qAll(selector){ return Array.from(document.querySelectorAll(selector)); }
  function q(selector){ return document.querySelector(selector); }

  // --- existing DOM nodes used by original code ---
  const namesRow = document.getElementById("moleculeNames");
  const coefsRow = document.getElementById("moleculeCoefs");

  // recreate functions that were used in the original code
  function makeMolNameCell(mol, side){
    const th = document.createElement("th");
    th.setAttribute("scope","col");
    const sideClass = side === 'reactant' ? 'reactant' : 'product';
    th.innerHTML = `
      <div class="mol-header">
        <div class="mol-name ${sideClass}" data-mol="${mol.id}" id="name_${mol.id}" title="${mol.label}">${mol.label}</div>
      </div>`;
    return th;
  }
  function makeCoefCell(mol){
    const th = document.createElement("th");
    th.setAttribute("scope","col");
    th.innerHTML = `
      <div>
        <input class="coef" aria-label="–ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç ${mol.label}" data-mol="${mol.id}" type="number" min="0" max="${MAX_COEF}" step="1" value="1">
      </div>`;
    return th;
  }

  // function defaultIndex used by original code; it reads from defaultIndexMap defined above
  function defaultIndex(mol, elem){
    if(!defaultIndexMap[mol]){
      if(!warnedMissingMol.has(mol)){
        console.warn(`defaultIndex: –Ω–µ–º–∞—î –∑–∞–ø–∏—Å—É –¥–ª—è –º–æ–ª–µ–∫—É–ª–∏ ${mol} —É defaultIndexMap ‚Äî –ø–æ–≤–µ—Ä—Ç–∞—é 0`);
        warnedMissingMol.add(mol);
      }
      return 0;
    }
    return (defaultIndexMap[mol][elem]) ? defaultIndexMap[mol][elem] : 0;
  }

  // build initial UI (same as original)
  reactants.forEach(m => { namesRow.appendChild(makeMolNameCell(m,'reactant')); coefsRow.appendChild(makeCoefCell(m)); });
  products.forEach(m => { namesRow.appendChild(makeMolNameCell(m,'product')); coefsRow.appendChild(makeCoefCell(m)); });

  const body = document.getElementById("elementsBody");
  function buildInitialElementsTable(){
    body.innerHTML = "";
    elements.forEach((elem, idx) => {
      const tr = document.createElement("tr");
      const tdElem = document.createElement("td"); tdElem.className = "elem-cell"; tdElem.textContent = elem; tr.appendChild(tdElem);
      const tdX = document.createElement("td");
      tdX.innerHTML = `<input type="radio" name="axis-x" aria-label="–û–±—Ä–∞—Ç–∏ ${elem} —è–∫ X" value="${elem}" ${idx===0 ? "checked" : ""}>`;
      tr.appendChild(tdX);
      const tdY = document.createElement("td");
      tdY.innerHTML = `<input type="radio" name="axis-y" aria-label="–û–±—Ä–∞—Ç–∏ ${elem} —è–∫ Y" value="${elem}" ${idx===1 ? "checked" : ""}>`;
      tr.appendChild(tdY);

      reactants.forEach(m => {
        const td = document.createElement("td");
        td.innerHTML = `<input class="num cell left" data-mol="${m.id}" data-elem="${elem}" type="number" value="${defaultIndex(m.id, elem)}" min="0" step="1" aria-label="–Ü–Ω–¥–µ–∫—Å –µ–ª–µ–º–µ–Ω—Ç–∞ ${elem} –≤ ${m.label}">`;
        tr.appendChild(td);
      });

      const rpTd = document.createElement("td"); rpTd.className = "rp-cell"; rpTd.id = `rp_${elem}`; rpTd.textContent = "0"; tr.appendChild(rpTd);

      products.forEach(m => {
        const td = document.createElement("td");
        td.innerHTML = `<input class="num cell right" data-mol="${m.id}" data-elem="${elem}" type="number" value="${defaultIndex(m.id, elem)}" min="0" step="1" aria-label="–Ü–Ω–¥–µ–∫—Å –µ–ª–µ–º–µ–Ω—Ç–∞ ${elem} –≤ ${m.label}">`;
        tr.appendChild(td);
      });

      body.appendChild(tr);
    });
  }
  buildInitialElementsTable();

  // Existing functions updateDifference, drawVectors... (the rest of your original script)
  // For brevity in this proposal I assume those functions remain unchanged from your original file.
  // I will re-use updateDifference() and drawVectors() defined below (they must exactly match your original).
  // --- (insert your original updateDifference, drawVectors, etc. definitions here) ---

  // To keep this proposal concise I won't duplicate the entire original large drawVectors() body here,
  // because you already have it in the file. The important addition is the parser integration below.

  // --- PARSER INTEGRATION: parse and rebuild table using predictor's parser functions ---
  // parseAndLoadEquation uses Elems_List() and Equation_Split() from chem_parser.js
  async function parseAndLoadEquation() {
    const txt = (document.getElementById('parsedInput')||{value:""}).value.trim();
    if(!txt) { alert("–í—Å—Ç–∞–≤—Ç–µ –∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–µ —Ä—ñ–≤–Ω—è–Ω–Ω—è —É –ø–æ–ª–µ –≤–∏—â–µ."); return; }

    // Use predictor's parser
    // Elems_List returns array with [original string, elem1, elem2, ...]
    let elemsArr;
    try {
      elemsArr = Elems_List(txt); // provided by chem_parser.js
    } catch (e) {
      console.error("Elems_List failed:", e);
      alert("–ü–æ–º–∏–ª–∫–∞ –ø–∞—Ä—Å–µ—Ä–∞: –Ω–µ –≤–¥–∞–ª–æ—Å—è –≤–∏—Ç—è–≥—Ç–∏ —Å–ø–∏—Å–æ–∫ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤.");
      return;
    }
    // Equation_Split returns [inStr, Cur.Reag_Rct, Cur.Reag_Prd]
    let eqSplit;
    try {
      eqSplit = Equation_Split(txt); // provided by chem_parser.js
    } catch (e) {
      console.error("Equation_Split failed:", e);
      alert("–ü–æ–º–∏–ª–∫–∞ –ø–∞—Ä—Å–µ—Ä–∞: –Ω–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑—ñ–±—Ä–∞—Ç–∏ —Ä—ñ–≤–Ω—è–Ω–Ω—è.");
      return;
    }

    const reagR = eqSplit[1]; // array: reagR[1..n] each is [coef, arrFormula]
    const reagP = eqSplit[2];

    // Build elements array (flat list of symbols)
    const parsedElements = [];
    for(let i=1;i<elemsArr.length;i++) parsedElements.push(elemsArr[i]);

    // Build reactants/products arrays in the same shape as visualiser expects
    function mkMolList(arr, sidePrefix){
      const list = [];
      for(let i=1;i<arr.length;i++){
        const coef = arr[i][0];
        const arrFormula = arr[i][1]; // arrFormula[0][0] is original formula text; arrFormula[1..] are [elem, count]
        const origLabel = (Array.isArray(arrFormula) && arrFormula[0] && arrFormula[0][0]) ? arrFormula[0][0] : ("mol"+i);
        // generate unique id
        const safeIdBase = origLabel.toString().toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_+|_+$/g,'') || (sidePrefix+i);
        let id = safeIdBase;
        let idx = 1;
        while(list.some(x => x.id === id)) { id = safeIdBase + "_" + (idx++); }
        list.push({ id: id, label: origLabel.toString(), coef: Math.max(0, Math.floor(Number(coef)||0)), formulaArray: arrFormula });
      }
      return list;
    }

    const parsedReactants = mkMolList(reagR, "r");
    const parsedProducts  = mkMolList(reagP, "p");

    // Build defaultIndexMap from parsed formula arrays
    const newDefaultIndexMap = {};
    function formulaArrToMap(formulaArr){
      const m = {};
      if(!Array.isArray(formulaArr)) return m;
      for(let j=1;j<formulaArr.length;j++){
        const p = formulaArr[j]; // [elem, index]
        if(!p) continue;
        const el = p[0];
        const val = Number(p[1]) || 0;
        m[el] = (m[el] || 0) + val;
      }
      return m;
    }
    parsedReactants.forEach(m => newDefaultIndexMap[m.id] = formulaArrToMap(m.formulaArray));
    parsedProducts.forEach(m => newDefaultIndexMap[m.id] = formulaArrToMap(m.formulaArray));

    // Now rebuild the table header (molecule names and coefficient inputs) and elements body
    // Clear existing headings
    namesRow.innerHTML = "";
    coefsRow.innerHTML = "";

    // Replace reactants & products variables used by UI code
    reactants = parsedReactants.map(m => ({ id: m.id, label: m.label }));
    products  = parsedProducts.map(m => ({ id: m.id, label: m.label }));
    defaultIndexMap = newDefaultIndexMap;
    elements = parsedElements.length ? parsedElements : elements; // if parser found elements, replace

    // Build molecule header
    reactants.forEach(m => { namesRow.appendChild(makeMolNameCell(m,'reactant')); coefsRow.appendChild(makeCoefCell(m)); });
    products.forEach(m => { namesRow.appendChild(makeMolNameCell(m,'product')); coefsRow.appendChild(makeCoefCell(m)); });

    // Rebuild elements table
    buildInitialElementsTable();

    // Set coefficients to parser-provided values if any
    reactants.forEach(m => {
      const coefInp = q(`.coef[data-mol="${m.id}"]`);
      const parsed = parsedReactants.find(x => x.id === m.id);
      if(coefInp && parsed) coefInp.value = Math.max(0, Math.min(MAX_COEF, Math.floor(parsed.coef || 0))) || 1;
    });
    products.forEach(m => {
      const coefInp = q(`.coef[data-mol="${m.id}"]`);
      const parsed = parsedProducts.find(x => x.id === m.id);
      if(coefInp && parsed) coefInp.value = Math.max(0, Math.min(MAX_COEF, Math.floor(parsed.coef || 0))) || 1;
    });

    // Populate element indices from defaultIndexMap
    document.querySelectorAll('.cell').forEach(inp => {
      const molId = inp.dataset.mol;
      const elem = inp.dataset.elem;
      const val = (defaultIndexMap[molId] && defaultIndexMap[molId][elem]) ? defaultIndexMap[molId][elem] : 0;
      inp.value = val;
    });

    // Update side composition text quick summary
    const compR = document.getElementById('compR');
    const compP = document.getElementById('compP');
    if(compR) compR.innerHTML = reactants.map(m => `‚Ä¢ ${m.label}`).join('<br>');
    if(compP) compP.innerHTML = products.map(m => `‚Ä¢ ${m.label}`).join('<br>');

    // Trigger existing update/draw functions from main UI
    try{
      // if updateDifference and drawVectors exist in scope, call them
      if(typeof updateDifference === 'function') updateDifference();
      if(typeof saveStateDebounced === 'function') saveStateDebounced(0);
      if(typeof drawVectors === 'function') drawVectors();
    }catch(e){
      console.warn("Could not trigger existing update/draw functions:", e);
    }

    // Put a helpful message
    const equationBox = document.getElementById('equation');
    if(equationBox) equationBox.innerText = txt;
  }

  // wire buttons
  const loadBtn = document.getElementById('loadParsedBtn');
  if(loadBtn) loadBtn.addEventListener('click', parseAndLoadEquation);
  const clearBtn = document.getElementById('clearParsedBtn');
  if(clearBtn) clearBtn.addEventListener('click', () => {
    document.getElementById('parsedInput').value = "";
  });

  // Note: you already have the rest of the UI interactivity (listeners for .cell, .coef,
  // axis selectors, drawVectors and updateDifference). The new routine simply reconstructs
  // header/body from the parser output and then calls the existing update/draw routines.

});
</script>

</body>
</html>