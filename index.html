<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>–Ü–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞ —Ç–∞–±–ª–∏—Ü—è ‚Äî –±–∞–ª–∞–Ω—Å —Ä–µ–∞–∫—Ü—ñ—ó + –≤–µ–∫—Ç–æ—Ä–∏ (fixed layout)</title>

<style>
  :root{ --accent:#2a9df4; --pos:#1e6ed1; --neg:#e85d5d; --border:#9aa; --bg-react:#eef7ff; --bg-prod:#fff3f3; }
  /* Box sizing reset to avoid unexpected overflow */
  *, *::before, *::after { box-sizing: border-box; }

  body{background:#f6f9fc; margin:0; padding:0; font-family:Arial, sans-serif; color:#222;}
  .chem-wrap{ max-width:1200px; width:calc(100% - 32px); margin:24px auto; background:#fff; padding:16px; border-radius:12px; box-shadow:0 2px 6px rgba(0,0,0,0.08); overflow:hidden; }
  .title{text-align:center; font-weight:700; margin-bottom:6px; font-size:20px;}
  .eq{ text-align:center; margin-bottom:12px; font-size:18px;}
  .formula-box{display:flex; gap:8px; justify-content:center; flex-wrap:wrap; align-items:center; margin-bottom:8px;}
  .formula-part{display:inline-flex; align-items:center; gap:6px; font-weight:600;}
  .controls-row{display:flex; gap:12px; align-items:center; justify-content:center; margin-bottom:12px; flex-wrap:wrap;}
  .layout{ display:grid; grid-template-columns: 1fr minmax(320px, 520px); gap:16px; align-items:start; }
  @media (max-width:1100px){ .layout{grid-template-columns:1fr;} }
  table.chem{border-collapse:collapse; width:100%;}
  table.chem caption{caption-side:top; font-weight:700; margin-bottom:8px; text-align:left;}
  table.chem th, table.chem td{border:1px solid var(--border); padding:6px; text-align:center; min-width:46px; background:#fff; vertical-align:middle;}
  table.chem th{background:#e6f0fb; font-weight:700;}
  .elem-cell{background:#fafafa; font-weight:600;}
  input.num{width:100%; border:0; text-align:center; font-size:14px; padding:4px; background:transparent;}
  input.num:focus{outline:1px solid var(--accent); background:#eef7ff;}
  .coef{width:56px; padding:6px; text-align:center; border-radius:6px; border:1px solid #d7eafb; background:#f8fbff;}
  .coef-row th{background:#f4f8ff;}
  .mol-header{display:flex; flex-direction:column; gap:6px; align-items:center; justify-content:center;}
  .mol-name{font-weight:700; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:100px;}
  .mol-name.reactant{ color: var(--pos); }
  .mol-name.product{ color: var(--neg); }
  .group-reactants{ background: linear-gradient(180deg,var(--bg-react),#f7fbff); color:var(--pos); }
  .group-products{ background: linear-gradient(180deg,var(--bg-prod),#fff7f7); color:var(--neg); }
  .rp-cell{min-height:36px; min-width:64px; display:flex; align-items:center; justify-content:center; background:#fff; transition:color 0.15s, background 0.15s;}
  .rp-zero{color:#333;}
  .rp-pos{color:var(--pos); font-weight:700;}
  .rp-neg{color:var(--neg); font-weight:700;}
  .note{font-size:13px; color:#555; text-align:center; margin-top:8px;}
  .mol-fallback{opacity:0.7; font-style:italic;}
  .rp-header{ white-space:nowrap; vertical-align:middle; }

  .vector-panel{ background:#fff; border:1px solid #e2eefc; border-radius:10px; padding:8px; max-width:100%; overflow:hidden; }
  .vector-title{font-weight:700; font-size:15px; margin-bottom:8px; text-align:center;}
  .vector-svg{ width:100%; height:auto; display:block; background:linear-gradient(180deg,#fbfeff,#f7fbff); border-radius:8px; border:1px solid #e6f7ff; max-width:100%; overflow:hidden; }

  .axis-labels{display:flex; justify-content:space-between; align-items:center; gap:8px; padding:0 6px 6px 6px; margin-bottom:6px;}
  .axis-labels .axis-box{display:flex; flex-direction:column; align-items:center;}
  .axis-labels .axis-box .axis-title{font-weight:700; font-size:12px; color:#334;}
  .axis-labels .y-label{ font-weight:700; color:#1e6ed1; } /* —Å–∏–Ω—è –¥–ª—è —Ä–µ–∞–∫—Ç–∞–Ω—Ç—ñ–≤ */
  .axis-labels .x-label{ font-weight:700; color:#e85d5d; } /* —á–µ—Ä–≤–æ–Ω–∞ –¥–ª—è –ø—Ä–æ–¥—É–∫—Ç—ñ–≤ */
  .vector-legend{font-size:13px; margin-top:8px; color:#444; text-align:left;}
  .method-def{font-size:13px; margin-top:10px; color:#333; background:#fbfdff; padding:8px; border-radius:6px; border:1px solid #eef6ff;}
  .method-def b{color:#112;}
  .axis-selectors{display:flex; gap:8px; justify-content:center; align-items:center; margin-bottom:8px; flex-wrap:wrap;}
  .axis-selectors label{font-size:13px; color:#333;}
  .order-selectors{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}

  .mapping-note-inline{font-size:14px; color:#2b4758; margin-top:8px; padding:6px 8px; background:#f7fbff; border-radius:6px; border:1px solid #e1f0ff; text-align:left; white-space:normal; line-height:1.3;}
  @media (max-width:880px){ .coef{width:48px;} table.chem th, table.chem td{font-size:13px; padding:6px;} .formula-box{font-size:15px;} }

  .svg-axis-label { font-family: Arial, sans-serif; font-size:11px; fill:#246; }
  .svg-tick { stroke:#79a9d9; stroke-width:1; }

  .legend-inline{display:flex; gap:10px; align-items:center; font-size:13px;}
  .legend-dot{width:12px; height:12px; border-radius:6px; display:inline-block; margin-right:6px;}
  .legend-react{ background:#5da0e8; }
  .legend-prod{ background:#e85d5d; }

  .parse-panel { display:flex; gap:10px; align-items:flex-start; justify-content:center; margin-bottom:12px; flex-wrap:wrap; }
  .parse-panel textarea { width:520px; min-height:56px; padding:8px; border-radius:6px; border:1px solid #d7eafb; resize:vertical; background:#fbfeff; }
  .parse-panel button { padding:8px 10px; border-radius:6px; background:var(--accent); color:#fff; border:0; cursor:pointer; }
  .muted { opacity: 0.45; font-style:italic; }
</style>
</head>
<body>

<div class="chem-wrap">
  <div class="title">–Ü–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞ —Ç–∞–±–ª–∏—Ü—è ‚Äî –±–∞–ª–∞–Ω—Å —Ä–µ–∞–∫—Ü—ñ—ó + –≤–µ–∫—Ç–æ—Ä–∏</div>

  <!-- INPUT PANEL: paste a balanced equation here -->
  <div class="parse-panel" aria-label="Load balanced equation">
    <div style="font-size:13px; color:#444; align-self:center;"><b>–í—Å—Ç–∞–≤—Ç–µ –∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–µ —Ä—ñ–≤–Ω—è–Ω–Ω—è (–æ–¥–Ω–∞ —Ä–µ–∞–∫—Ü—ñ—è):</b></div>
    <textarea id="parsedInput" placeholder="–ù–∞–ø—Ä.: 2 H2 + O2 = 2 H2O"></textarea>
    <div style="display:flex; flex-direction:column; gap:8px;">
      <button id="loadParsedBtn" type="button">Load & Visualize</button>
      <button id="clearParsedBtn" type="button" style="background:#999;">Clear</button>
    </div>
  </div>
  <!-- /INPUT PANEL -->

  <div class="eq" aria-live="polite">
    <!-- Always-visible active equation (updated by buildEquation) -->
    <div class="formula-box" id="equation"></div>
    <div style="font-size:13px; color:#444;">(–†–µ–∞–∫—Ç–∞–Ω—Ç–∏ –∑–ª—ñ–≤–∞ ‚Äî –ü—Ä–æ–¥—É–∫—Ç–∏ —Å–ø—Ä–∞–≤–∞)</div>
  </div>

  <div class="controls-row">
    <div style="font-size:13px; color:#444;">–û–±–µ—Ä—ñ—Ç—å –æ—Å—ñ –¥–ª—è –≤–µ–∫—Ç–æ—Ä—ñ–≤ (X, Y):</div>
    <div class="axis-selectors" id="axisSelectors"></div>

    <div class="order-selectors" id="orderSelectors" style="margin-left:8px;">
      <label style="font-size:13px;color:#333;">–ü–æ—Ä—è–¥–æ–∫ R:</label>
      <select id="orderR" style="padding:4px;font-size:13px;">
        <option value="auto">auto (‚Üë by size)</option>
        <option value="asc">asc (by size)</option>
        <option value="desc">desc (by size)</option>
        <option value="none">none (as is)</option>
      </select>
      <label style="font-size:13px;color:#333;">–ü–æ—Ä—è–¥–æ–∫ P:</label>
      <select id="orderP" style="padding:4px;font-size:13px;">
        <option value="auto">auto (‚Üì by size)</option>
        <option value="asc">asc (by size)</option>
        <option value="desc">desc (by size)</option>
        <option value="none">none (as is)</option>
      </select>
    </div>
  </div>

  <div class="layout">
    <div>
      <table class="chem" id="mainTable" aria-label="–¢–∞–±–ª–∏—Ü—è –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ —ñ –º–æ–ª–µ–∫—É–ª">
        <caption>–¢–∞–±–ª–∏—Ü—è –∞—Ç–æ–º–Ω–∏—Ö —ñ–Ω–¥–µ–∫—Å—ñ–≤ (—Ä–µ–∞–∫—Ç–∞–Ω—Ç–∏ ‚Äî –ª—ñ–≤–æ—Ä—É—á, –ø—Ä–æ–¥—É–∫—Ç–∏ ‚Äî –ø—Ä–∞–≤–æ—Ä—É—á). –ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ –≤–∏–Ω–µ—Å–µ–Ω—ñ –æ–∫—Ä–µ–º–∏–º —Ä—è–¥–∫–æ–º –Ω–∞–¥ —ñ–Ω–¥–µ–∫—Å–∞–º–∏.</caption>
        <thead>
          <tr>
            <th scope="col" rowspan="3">–ï–ª–µ–º–µ–Ω—Ç</th>
            <th scope="col" rowspan="3">X</th>
            <th scope="col" rowspan="3">Y</th>
            <th scope="col" colspan="3" class="group-reactants">–†–µ–∞–∫—Ç–∞–Ω—Ç–∏</th>
            <th scope="col" rowspan="3" class="rp-header">R ‚àí P</th>
            <th scope="col" colspan="5" class="group-products">–ü—Ä–æ–¥—É–∫—Ç–∏</th>
          </tr>
          <tr id="moleculeNames"></tr>
          <tr id="moleculeCoefs" class="coef-row"></tr>
        </thead>
        <tbody id="elementsBody"></tbody>
      </table>

      <div class="note">–ó–º—ñ–Ω—é–π —á–∏—Å–ª–∞ —ñ–Ω–¥–µ–∫—Å—ñ–≤ –∞–±–æ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ ‚Äî —Ä—ñ–≤–Ω—è–Ω–Ω—è, —Ä—ñ–∑–Ω–∏—Ü—è (R ‚àí P) —Ç–∞ –≤–µ–∫—Ç–æ—Ä–∏ –æ–Ω–æ–≤–ª—é—é—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ. –Ø–∫—â–æ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç 0 ‚Äî –º–æ–ª–µ–∫—É–ª—É –ø–æ–∫–∞–∑–∞–Ω–æ —Å—ñ—Ä–∏–º; 1 ‚Äî —Ü–∏—Ñ—Ä—É 1 –Ω–µ –ø–æ–∫–∞–∑—É—î–º–æ.</div>
    </div>

    <div class="vector-panel" aria-label="–ü–∞–Ω–µ–ª—å –≤–µ–∫—Ç–æ—Ä—ñ–≤">
      <div class="vector-title">–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω–∞ —Å—ñ—Ç–∫–∞ ‚Äî –≤–µ–∫—Ç–æ—Ä–Ω—ñ —à–ª—è—Ö–∏ —Ä–µ–∞–∫—Ç–∞–Ω—Ç—ñ–≤ —ñ –ø—Ä–æ–¥—É–∫—Ç—ñ–≤</div>

      <div class="axis-labels" aria-hidden="false">
        <div class="axis-box"><div class="axis-title">Y (–≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞) ‚Äî –†–µ–∞–∫—Ç–∞–Ω—Ç–∏ üîµ</div><div class="y-label" id="axisLabelY">Y:</div></div>
        <div class="axis-box"><div class="axis-title">X (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞) ‚Äî –ü—Ä–æ–¥—É–∫—Ç–∏ üî¥</div><div class="x-label" id="axisLabelX">X:</div></div>
      </div>

      <svg id="vectorSvg" class="vector-svg" viewBox="0 0 520 520" preserveAspectRatio="xMidYMid meet" role="img" aria-label="–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω–∞ —Å—ñ—Ç–∫–∞"></svg>

      <div style="margin-top:8px;">
        <div class="legend-inline"><span class="legend-dot legend-react"></span>–†–µ–∞–∫—Ç–∏–≤–Ω–∏–π —à–ª—è—Ö (R)</div>
        <div class="legend-inline" style="margin-top:4px;"><span class="legend-dot legend-prod"></span>–ü—Ä–æ–¥—É–∫—Ç–æ–≤–∏–π —à–ª—è—Ö (P)</div>
      </div>
    </div>
  </div>

  <div style="margin-top:12px;">
    <div class="vector-legend" id="vectorLegend">
      –¢–µ–ø–µ—Ä –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –ø–æ–∫–∞–∑—É—î –¥–≤–∞ –∫—É–º—É–ª—è—Ç–∏–≤–Ω—ñ —à–ª—è—Ö–∏: –æ–¥–∏–Ω –¥–ª—è —Ä–µ–∞–∫—Ç–∞–Ω—Ç—ñ–≤ (—Å–∏–Ω—ñ–π, R), —ñ–Ω—à–∏–π –¥–ª—è –ø—Ä–æ–¥—É–∫—Ç—ñ–≤ (—á–µ—Ä–≤–æ–Ω–∏–π, P). –ö–æ–∂–µ–Ω —Å–µ–≥–º–µ–Ω—Ç –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î –æ–¥–Ω—ñ–π –º–æ–ª–µ–∫—É–ª—ñ, –º–∞—Å—à—Ç–∞–±–æ–≤–∞–Ω–∏–π —ó—ó –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–æ–º.
    </div>

    <div class="method-def" id="methodDef" aria-live="polite" style="margin-top:10px;">
      <b>–§–æ—Ä–º–∞–ª—å–Ω—ñ –ø—Ä–∞–≤–∏–ª–∞ (–º—ñ–∫—Ä–æ‚Äë—Å–ø—Ä–∞–≤–∫–∞ –º–µ—Ç–æ–¥—É):</b>
      <ol>
        <li><b>–í–µ–∫—Ç–æ—Ä –º–æ–ª–µ–∫—É–ª–∏</b>: v = (n‚Çì, n·µß), –¥–µ n‚Çì,n·µß ‚Äî –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –∞—Ç–æ–º—ñ–≤ –≤–∏–±—Ä–∞–Ω–∏—Ö –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ —É –º–æ–ª–µ–∫—É–ª—ñ. –ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç k –æ–∑–Ω–∞—á–∞—î, —â–æ —Ü–µ–π –≤–µ–∫—Ç–æ—Ä –ø–æ–≤—Ç–æ—Ä—é—î—Ç—å—Å—è k —Ä–∞–∑—ñ–≤ (—Ç–æ–±—Ç–æ –∫–æ–∂–Ω–∞ –º–æ–ª–µ–∫—É–ª–∞ –æ–∫—Ä–µ–º–æ –¥–æ–¥–∞—î—Ç—å—Å—è –¥–æ —à–ª—è—Ö—É).</li>
        <li><b>–®–ª—è—Ö</b>: —à–ª—è—Ö —Å—É–º—ñ—à—ñ = –≤–ø–æ—Ä—è–¥–∫–æ–≤–∞–Ω–∞ (–ø–æ—Å–ª—ñ–¥–æ–≤–Ω–∞) —Å—É–º–∞ –≤–µ–∫—Ç–æ—Ä—ñ–≤ –º–æ–ª–µ–∫—É–ª (–∫–æ–∂–Ω–∞ –º–æ–ª–µ–∫—É–ª–∞ ‚Äî –æ–∫—Ä–µ–º–∏–π —Å–µ–≥–º–µ–Ω—Ç). –°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –º–æ–ª–µ–∫—É–ª –≤–ø–ª–∏–≤–∞—î –Ω–∞ —Ñ–æ—Ä–º—É —à–ª—è—Ö—É ‚Äî –≤–∏ –º–æ–∂–µ—Ç–µ –∫–µ—Ä—É–≤–∞—Ç–∏ —Ü–∏–º —É —Å–µ–ª–µ–∫—Ç–∞—Ö –Ω–∞–¥ –ø–∞–Ω–µ–ª–ª—é.</li>
        <li><b>–ü–æ—á–∞—Ç–∫–æ–≤–∞ —Ç–æ—á–∫–∞</b>: –æ–±–∏–¥–≤–∞ —à–ª—è—Ö–∏ –ø–æ—á–∏–Ω–∞—é—Ç—å—Å—è –∑ –æ–¥–Ω—ñ—î—ó –ø–æ—á–∞—Ç–∫–æ–≤–æ—ó —Ç–æ—á–∫–∏ (0,0) ‚Äî –Ω—É–ª—å–æ–≤–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ (–≤–Ω–∏–∑—É –∑–ª—ñ–≤–∞ –Ω–∞ –≥—Ä–∞—Ñ—ñ–∫—É).</li>
        <li><b>–ë–∞–ª–∞–Ω—Å</b>: —Ä–µ–∞–∫—Ü—ñ—è –∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–∞ ‚áî –≤–µ–∫—Ç–æ—Ä–Ω–∞ —Å—É–º–∞ —Ä–µ–∞–∫—Ç–∞–Ω—Ç—ñ–≤ = –≤–µ–∫—Ç–æ—Ä–Ω–∞ —Å—É–º–∞ –ø—Ä–æ–¥—É–∫—Ç—ñ–≤ (–∫—ñ–Ω—Ü–µ–≤—ñ —Ç–æ—á–∫–∏ —à–ª—è—Ö—ñ–≤ –∑–±—ñ–≥–∞—é—Ç—å—Å—è).</li>
        <li><b>–ü—Ä–æ—î–∫—Ü—ñ—è</b>: –≤–∏–±—ñ—Ä –æ—Å–µ–π X,Y ‚Äî —Ü–µ –ø—Ä–æ—î–∫—Ü—ñ—è –±–∞–≥–∞—Ç–æ–≤–∏–º—ñ—Ä–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å—É –Ω–∞ –ø–ª–æ—â–∏–Ω—É; –∑–±—ñ–≥ —É 2D –Ω–µ –≥–∞—Ä–∞–Ω—Ç—É—î –ø–æ–≤–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å—É –ø–æ –≤—Å—ñ—Ö –µ–ª–µ–º–µ–Ω—Ç–∞—Ö, –∞–ª–µ –Ω–µ–∑–±—ñ–≥ —É 2D –≥–∞—Ä–∞–Ω—Ç—É—î –Ω–µ–∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω—ñ—Å—Ç—å.</li>
        <li><b>–ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏</b>: —Å—Ç–µ—Ö—ñ–æ–º–µ—Ç—Ä–∏—á–Ω—ñ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ ‚Äî —Ü—ñ–ª—ñ –Ω–µ–≤—ñ–¥ º—î–º–Ω—ñ —á–∏—Å–ª–∞ (‚Ñï‚ÇÄ). –Ü–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∑–∞–±–µ–∑–ø–µ—á—É—î —Ü—é —É–º–æ–≤–∞ (min=0, step=1, –æ–∫—Ä—É–≥–ª–µ–Ω–Ω—è) —ñ –Ω–∞–∫–ª–∞–¥–∞—î –æ–±–º–µ–∂–µ–Ω–Ω—è max –¥–ª—è —É–Ω–∏–∫–Ω–µ–Ω–Ω—è –ø–µ—Ä–µ–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó.</li>
      </ol>
    </div>

    <div class="mapping-note-inline" id="mappingNote" aria-hidden="false" style="margin-top:8px;"></div>
  </div>

  <div class="composition-legend" style="background:#f7fbff; border:1px solid #e1f0ff; border-radius:8px; padding:12px; margin-top:12px;">
    <div style="font-weight:700; font-size:14px; margin-bottom:8px;">üìã –°–∫–ª–∞–¥ —Ä–µ–∞–∫—Ç–∞–Ω—Ç—ñ–≤ —Ç–∞ –ø—Ä–æ–¥—É–∫—Ç—ñ–≤: </div>
    <div style="display:flex; gap:20px;">
      <div>
        <div style="color:#1e6ed1; font-weight:700; margin-bottom:4px;">üîµ –†–µ–∞–∫—Ç–∞–Ω—Ç–∏ (R):</div>
        <div style="color:#445; font-size:13px; line-height:1.6;">
          ‚Ä¢ H‚ÇÇO (H:  2, O: 1)<br>
          ‚Ä¢ CO‚ÇÇ (C: 1, O: 2)<br>
          ‚Ä¢ O‚ÇÇ (O: 2)
        </div>
      </div>
      <div>
        <div style="color:#e85d5d; font-weight:700; margin-bottom:4px;">üî¥ –ü—Ä–æ–¥—É–∫—Ç–∏ (P):</div>
        <div style="color:#445; font-size:13px; line-height:1.6;">
          ‚Ä¢ H‚ÇÇ (H: 2)<br>
          ‚Ä¢ O‚ÇÉ (O: 3)<br>
          ‚Ä¢ H‚ÇÇCO‚ÇÉ (H: 2, C: 1, O:  3)<br>
          ‚Ä¢ N‚ÇÇ (N: 2)<br>
          ‚Ä¢ NH‚ÇÉ (N: 1, H: 3)
        </div>
      </div>
    </div>
  </div>

</div>

<!-- include parser if you want to use parse/load feature -->
<script src="chem_parser.js"></script>

<script>
document.addEventListener("DOMContentLoaded", () => {
  // Data and defaults
  const elements = ["H","C","O","N","P","S","F","Na","Ca"];
  let reactants = [
    {id:"h2o", label:"H2O"},
    {id:"co2", label:"CO2"},
    {id:"o2",  label:"O2"}
  ];
  let products = [
    {id:"h2",   label:"H2"},
    {id:"o3",   label:"O3"},
    {id:"h2co3",label:"H2CO3"},
    {id:"n2",   label:"N2"},
    {id:"nh3",  label:"NH3"}
  ];

  const MAX_COEF = 100;
  const MIN_AXIS_SPAN = 10;
  const VISUAL_OFFSET_PX = 2;
  const STORAGE_KEY = 'chem_balancer_state_v1';
  let defaultIndexMap = {
    h2o: {H:2,O:1},
    co2: {C:1,O:2},
    o2:  {O:2},
    h2:  {H:2},
    o3:  {O:3},
    h2co3:{H:2,C:1,O:3},
    n2:  {N:2},
    nh3: {N:1,H:3}
  };
  const warnedMissingMol = new Set();

  const namesRow = document.getElementById("moleculeNames");
  const coefsRow = document.getElementById("moleculeCoefs");
  const body = document.getElementById("elementsBody");
  const svg = document.getElementById("vectorSvg");
  svg.setAttribute('overflow','hidden');
  const svgSize = 520;
  const padding = 34;
  const mappingNoteEl = document.getElementById('mappingNote');

  // Helpers
  function q(selector){ return document.querySelector(selector); }
  function qAll(selector){ return Array.from(document.querySelectorAll(selector)); }

  function makeMolNameCell(mol, side){
    const th = document.createElement("th");
    th.setAttribute("scope","col");
    th.dataset.side = side;
    th.dataset.mol = mol.id;
    const sideClass = side === 'reactant' ? 'reactant' : 'product';
    th.innerHTML = `<div class="mol-header"><div class="mol-name ${sideClass}" data-mol="${mol.id}" id="name_${mol.id}" title="${mol.label}">${mol.label}</div></div>`;
    return th;
  }
  function makeCoefCell(mol, side){
    const th = document.createElement("th");
    th.setAttribute("scope","col");
    th.dataset.side = side;
    th.dataset.mol = mol.id;
    th.innerHTML = `<div><input class="coef" aria-label="–ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç ${mol.label}" data-mol="${mol.id}" type="number" min="0" max="${MAX_COEF}" step="1" value="1"></div>`;
    return th;
  }

  // Build header, stable order: reactants then products
  function buildMoleculeHeader(){
    namesRow.innerHTML = "";
    coefsRow.innerHTML = "";
    reactants.forEach(m => { namesRow.appendChild(makeMolNameCell(m,'reactant')); coefsRow.appendChild(makeCoefCell(m,'reactant')); });
    products.forEach(m => { namesRow.appendChild(makeMolNameCell(m,'product')); coefsRow.appendChild(makeCoefCell(m,'product')); });
  }
  buildMoleculeHeader();

  function defaultIndex(mol, elem){
    if(!defaultIndexMap[mol]){
      if(!warnedMissingMol.has(mol)){
        console.warn(`defaultIndex: –Ω–µ–º–∞—î –∑–∞–ø–∏—Å—É –¥–ª—è –º–æ–ª–µ–∫—É–ª–∏ ${mol} —É defaultIndexMap ‚Äî –ø–æ–≤–µ—Ä—Ç–∞—é 0`);
        warnedMissingMol.add(mol);
      }
      return 0;
    }
    return (defaultIndexMap[mol][elem]) ? defaultIndexMap[mol][elem] : 0;
  }

  function buildElementsTable(){
    body.innerHTML = "";
    elements.forEach((elem, idx) => {
      const tr = document.createElement("tr");
      const tdElem = document.createElement("td"); tdElem.className = "elem-cell"; tdElem.textContent = elem; tr.appendChild(tdElem);
      const tdX = document.createElement("td");
      tdX.innerHTML = `<input type="radio" name="axis-x" aria-label="–û–±—Ä–∞—Ç–∏ ${elem} —è–∫ X" value="${elem}" ${idx===0 ? "checked" : ""}>`;
      tr.appendChild(tdX);
      const tdY = document.createElement("td");
      tdY.innerHTML = `<input type="radio" name="axis-y" aria-label="–û–±—Ä–∞—Ç–∏ ${elem} —è–∫ Y" value="${elem}" ${idx===1 ? "checked" : ""}>`;
      tr.appendChild(tdY);

      reactants.forEach(m => {
        const td = document.createElement("td");
        td.innerHTML = `<input class="num cell left" data-mol="${m.id}" data-elem="${elem}" type="number" value="${defaultIndex(m.id, elem)}" min="0" step="1" aria-label="–Ü–Ω–¥–µ–∫—Å ${elem} –≤ ${m.label}">`;
        tr.appendChild(td);
      });

      const rpTd = document.createElement("td"); rpTd.className = "rp-cell"; rpTd.id = `rp_${elem}`; rpTd.textContent = "0"; tr.appendChild(rpTd);

      products.forEach(m => {
        const td = document.createElement("td");
        td.innerHTML = `<input class="num cell right" data-mol="${m.id}" data-elem="${elem}" type="number" value="${defaultIndex(m.id, elem)}" min="0" step="1" aria-label="–Ü–Ω–¥–µ–∫—Å ${elem} –≤ ${m.label}">`;
        tr.appendChild(td);
      });

      body.appendChild(tr);
    });
  }
  buildElementsTable();

  // Formula builder and diffs
  function buildFormulaHTML(molId){
    const parts = [];
    elements.forEach(el => {
      const input = document.querySelector(`.cell[data-mol="${molId}"][data-elem="${el}"]`);
      const val = input ? Number(input.value) || 0 : 0;
      if(val > 0) parts.push(el + (val > 1 ? `${val}` : ""));
    });
    return parts.length ? parts.join("") : `<span class="mol-fallback">${molId}</span>`;
  }

  function updateDifference(){
    elements.forEach(elem => {
      let leftSum = 0;
      qAll(`.left[data-elem="${elem}"]`).forEach(input => {
        const molId = input.dataset.mol;
        const coefInput = q(`.coef[data-mol="${molId}"]`);
        const coef = coefInput ? Math.max(0, Math.min(MAX_COEF, Math.floor(Number(coefInput.value) || 0))) : 0;
        leftSum += (Number(input.value) || 0) * coef;
      });
      let rightSum = 0;
      qAll(`.right[data-elem="${elem}"]`).forEach(input => {
        const molId = input.dataset.mol;
        const coefInput = q(`.coef[data-mol="${molId}"]`);
        const coef = coefInput ? Math.max(0, Math.min(MAX_COEF, Math.floor(Number(coefInput.value) || 0))) : 0;
        rightSum += (Number(input.value) || 0) * coef;
      });
      const diff = leftSum - rightSum;
      const cell = document.getElementById(`rp_${elem}`);
      if(!cell) return;
      cell.textContent = diff;
      cell.classList.remove("rp-pos","rp-neg","rp-zero");
      if(diff > 0) cell.classList.add("rp-pos");
      else if(diff < 0) cell.classList.add("rp-neg");
      else cell.classList.add("rp-zero");
    });
  }

  // localStorage
  function collectState(){
    const state = { coeffs: {}, cells: {}, axes: {}, orderR: null, orderP: null, axisSelects: {} , reactants:[], products:[], elements:[]};
    qAll('.coef').forEach(inp => {
      const mol = inp.dataset.mol;
      state.coeffs[mol] = Math.max(0, Math.min(MAX_COEF, Math.floor(Number(inp.value) || 0)));
    });
    qAll('.cell').forEach(inp => {
      const mol = inp.dataset.mol;
      const el = inp.dataset.elem;
      if(!state.cells[mol]) state.cells[mol] = {};
      state.cells[mol][el] = Math.max(0, Math.floor(Number(inp.value) || 0));
    });
    const selX = q('select[data-axis="x"]');
    const selY = q('select[data-axis="y"]');
    if(selX) state.axisSelects.x = selX.value;
    if(selY) state.axisSelects.y = selY.value;
    const rx = q('input[name="axis-x"]:checked')?.value;
    const ry = q('input[name="axis-y"]:checked')?.value;
    if(rx) state.axes.x = rx;
    if(ry) state.axes.y = ry;
    state.orderR = q('#orderR')?.value || null;
    state.orderP = q('#orderP')?.value || null;

    state.reactants = reactants.slice();
    state.products = products.slice();
    state.elements = elements.slice();

    return state;
  }

  function restoreState(state){
    if(!state) return;
    try{
      if(state.reactants && state.products && state.elements){
        reactants = state.reactants.slice();
        products = state.products.slice();
        elements.length = 0;
        state.elements.forEach(e => elements.push(e));
        buildMoleculeHeader();
        buildElementsTable();
      }

      if(state.coeffs){
        Object.keys(state.coeffs).forEach(mol => {
          const inp = q(`.coef[data-mol="${mol}"]`);
          if(inp) inp.value = Math.max(0, Math.min(MAX_COEF, Math.floor(Number(state.coeffs[mol] || 0))));
        });
      }
      if(state.cells){
        Object.keys(state.cells).forEach(mol => {
          Object.keys(state.cells[mol]).forEach(el => {
            const inp = q(`.cell[data-mol="${mol}"][data-elem="${el}"]`);
            if(inp) inp.value = Math.max(0, Math.floor(Number(state.cells[mol][el] || 0)));
          });
        });
      }
      if(state.axisSelects && (state.axisSelects.x || state.axisSelects.y)){
        if(state.axisSelects.x){
          const sel = q('select[data-axis="x"]');
          if(sel) sel.value = state.axisSelects.x;
          const r = q(`input[name="axis-x"][value="${state.axisSelects.x}"]`);
          if(r) r.checked = true;
        }
        if(state.axisSelects.y){
          const sel = q('select[data-axis="y"]');
          if(sel) sel.value = state.axisSelects.y;
          const r = q(`input[name="axis-y"][value="${state.axisSelects.y}"]`);
          if(r) r.checked = true;
        }
      } else if(state.axes){
        if(state.axes.x){
          const r = q(`input[name="axis-x"][value="${state.axes.x}"]`);
          if(r) r.checked = true;
          const sel = q('select[data-axis="x"]');
          if(sel) sel.value = state.axes.x;
        }
        if(state.axes.y){
          const r = q(`input[name="axis-y"][value="${state.axes.y}"]`);
          if(r) r.checked = true;
          const sel = q('select[data-axis="y"]');
          if(sel) sel.value = state.axes.y;
        }
      }
      if(state.orderR && q('#orderR')) q('#orderR').value = state.orderR;
      if(state.orderP && q('#orderP')) q('#orderP').value = state.orderP;
    }catch(e){
      console.warn("restoreState: couldn't restore fully", e);
    }
  }

  function saveState(){
    try{
      const state = collectState();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }catch(e){
      console.warn("saveState failed", e);
    }
  }
  let saveTimeout = null;
  function saveStateDebounced(delay = 350){
    if(saveTimeout) clearTimeout(saveTimeout);
    saveTimeout = setTimeout(() => { saveState(); saveTimeout = null; }, delay);
  }
  function loadState(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return null;
      const parsed = JSON.parse(raw);
      return parsed;
    }catch(e){
      console.warn("loadState failed", e);
      return null;
    }
  }

  // Axis selectors
  const axisSelectors = document.getElementById("axisSelectors");
  function buildAxisSelectors(){
    axisSelectors.innerHTML = "";
    const createSelect = (labelText, name) => {
      const wrapper = document.createElement('div');
      wrapper.style.display = 'flex'; wrapper.style.flexDirection = 'column'; wrapper.style.alignItems = 'center'; wrapper.style.gap = '6px';
      const lbl = document.createElement('label'); lbl.textContent = labelText; lbl.style.fontWeight = '600'; lbl.style.fontSize = '13px'; wrapper.appendChild(lbl);
      const sel = document.createElement('select'); sel.style.fontSize = '13px'; sel.style.padding = '4px';
      elements.forEach((el, idx) => { const opt = document.createElement('option'); opt.value = el; opt.textContent = el; if((name === 'x' && idx === 0) || (name === 'y' && idx === 1)) opt.selected = true; sel.appendChild(opt); });
      sel.addEventListener('change', () => {
        const val = sel.value;
        const radioName = name === 'x' ? 'axis-x' : 'axis-y';
        const r = q(`input[name="${radioName}"][value="${val}"]`);
        if(r) r.checked = true;
        const otherSel = axisSelectors.querySelector(`select[data-axis="${name === 'x' ? 'y' : 'x'}"]`);
        if(otherSel && otherSel.value === val){
          for(const el of elements){ if(el !== val){ otherSel.value = el; const otherRadio = q(`input[name="${name === 'x' ? 'axis-y' : 'axis-x'}"][value="${el}"]`); if(otherRadio) otherRadio.checked = true; break; } }
        }
        drawVectors();
      });
      sel.setAttribute('data-axis', name);
      wrapper.appendChild(sel);
      return wrapper;
    };
    axisSelectors.appendChild(createSelect('X', 'x'));
    axisSelectors.appendChild(createSelect('Y', 'y'));
    qAll('input[name="axis-x"]').forEach(r => r.addEventListener('change', () => { const val = r.value; const sel = axisSelectors.querySelector('select[data-axis="x"]'); if(sel) sel.value = val; drawVectors(); }));
    qAll('input[name="axis-y"]').forEach(r => r.addEventListener('change', () => { const val = r.value; const sel = axisSelectors.querySelector('select[data-axis="y"]'); if(sel) sel.value = val; drawVectors(); }));
  }
  buildAxisSelectors();

  // drawVectors (same restored algorithm as before)
  function niceStep(range, targetTicks = 6){
    if(range <= 0) return 1;
    const raw = range / targetTicks;
    const pow = Math.pow(10, Math.floor(Math.log10(raw)));
    const candidates = [1,2,5,10].map(m => m * pow);
    for(const c of candidates){
      if(c >= raw) return c;
    }
    return candidates[candidates.length - 1];
  }
  function moleculeSize(mol){
    let s = 0;
    elements.forEach(el => {
      const input = q(`.cell[data-mol="${mol.id}"][data-elem="${el}"]`);
      const val = input ? Math.max(0, Math.floor(Number(input.value) || 0)) : 0;
      s += val;
    });
    return s;
  }

  function getSelectedAxes(){
    const x = q('input[name="axis-x"]:checked')?.value || elements[0];
    const y = q('input[name="axis-y"]:checked')?.value || elements[1] || elements[0];
    if(x === y){
      for(const el of elements){
        if(el !== x){
          const r = q(`input[name="axis-y"][value="${el}"]`);
          if(r) r.checked = true;
          return { x, y: el };
        }
      }
    }
    return { x, y };
  }

  function buildGrossFormula(molList){
    const acc = {};
    elements.forEach(el => acc[el] = 0);
    molList.forEach(m => {
      const coef = Math.max(0, Math.min(MAX_COEF, Math.floor(Number(q(`.coef[data-mol="${m.id}"]`)?.value || 0))));
      if(coef === 0) return;
      elements.forEach(el => {
        const input = q(`.cell[data-mol="${m.id}"][data-elem="${el}"]`);
        const val = input ? Math.max(0, Math.floor(Number(input.value) || 0)) : 0;
        acc[el] += val * coef;
      });
    });
    const parts = [];
    for(const el of elements){
      if(acc[el] > 0) parts.push(`${el}${acc[el] > 1 ? acc[el] : ''}`);
    }
    return parts.length ? `(${parts.join(',')})` : `(‚Äî)`;
  }

  function drawFallbackGrid(){
    while (svg.firstChild) svg.removeChild(svg.firstChild);
    const inner = svgSize - padding * 2;
    const step = inner / 10;
    for(let i=0;i<=10;i++){
      for(let j=0;j<=10;j++){
        const x = padding + i * step;
        const y = padding + (10 - j) * step;
        const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
        dot.setAttribute("cx", x.toString());
        dot.setAttribute("cy", y.toString());
        dot.setAttribute("r", "2");
        dot.setAttribute("fill", "#d9eefe");
        svg.appendChild(dot);
      }
    }
    const axisX = document.createElementNS("http://www.w3.org/2000/svg","line");
    axisX.setAttribute("x1", padding.toString()); axisX.setAttribute("y1", (svgSize - padding).toString()); axisX.setAttribute("x2", (svgSize - padding).toString()); axisX.setAttribute("y2", (svgSize - padding).toString()); axisX.setAttribute("stroke","#79a9d9"); axisX.setAttribute("stroke-width","1.5"); svg.appendChild(axisX);
    const axisY = document.createElementNS("http://www.w3.org/2000/svg","line");
    axisY.setAttribute("x1", padding.toString()); axisY.setAttribute("y1", padding.toString()); axisY.setAttribute("x2", padding.toString()); axisY.setAttribute("y2", (svgSize - padding).toString()); axisY.setAttribute("stroke","#79a9d9"); axisY.setAttribute("stroke-width","1.5"); svg.appendChild(axisY);
  }

  function drawVectors(){
    // The full drawVectors implementation is long and kept as in previous working version.
    // For brevity here we call the same algorithm as earlier in the file (restored previously).
    // Reuse the version from earlier assistant message (kept unchanged).
    // Implementation starts:
    while (svg.firstChild) svg.removeChild(svg.firstChild);
    const defs = document.createElementNS("http://www.w3.org/2000/svg","defs");
    const makeMarker = (id, color) => {
      const marker = document.createElementNS("http://www.w3.org/2000/svg","marker");
      marker.setAttribute("id", id); marker.setAttribute("markerWidth", "6"); marker.setAttribute("markerHeight", "6");
      marker.setAttribute("refX", "6"); marker.setAttribute("refY", "3"); marker.setAttribute("orient", "auto"); marker.setAttribute("markerUnits", "strokeWidth");
      const path = document.createElementNS("http://www.w3.org/2000/svg","path"); path.setAttribute("d", "M0,0 L6,3 L0,6 z"); path.setAttribute("fill", color);
      marker.appendChild(path); return marker;
    };
    defs.appendChild(makeMarker("arrowR","#5da0e8"));
    defs.appendChild(makeMarker("arrowP","#e85d5d"));
    svg.appendChild(defs);

    const axes = getSelectedAxes();
    const axisLabelX = document.getElementById('axisLabelX');
    const axisLabelY = document.getElementById('axisLabelY');
    if(axisLabelX) axisLabelX.textContent = `X: ${axes.x}`;
    if(axisLabelY) axisLabelY.textContent = `Y: ${axes.y}`;

    function readCountRaw(molId, elemName){
      const inp = q(`.cell[data-mol="${molId}"][data-elem="${elemName}"]`);
      return inp ? Math.max(0, Math.floor(Number(inp.value) || 0)) : 0;
    }
    const orderR = q('#orderR')?.value || 'auto';
    const orderP = q('#orderP')?.value || 'auto';
    function orderList(list, orderPref, defaultBehavior){
      if(orderPref === 'none') return list.slice();
      const withSize = list.map(m => ({m, size: moleculeSize(m)}));
      if(orderPref === 'auto') orderPref = defaultBehavior;
      if(orderPref === 'asc'){
        withSize.sort((a,b) => a.size - b.size);
      } else if(orderPref === 'desc'){
        withSize.sort((a,b) => b.size - a.size);
      }
      return withSize.map(x => x.m);
    }
    const reactantsOrdered = orderList(reactants, orderR, 'asc');
    const productsOrdered  = orderList(products,  orderP, 'desc');

    function buildCumulativePathByInstancesOrdered(molListOrdered){
      const pts = []; let current = { x: 0, y: 0 }; pts.push({ x: current.x, y: current.y, label: null });
      molListOrdered.forEach((mol) => {
        const coefInput = q(`.coef[data-mol="${mol.id}"]`);
        const coef = coefInput ? Math.max(0, Math.min(MAX_COEF, Math.floor(Number(coefInput.value) || 0))) : 0;
        if(coef === 0) return;
        const vx = readCountRaw(mol.id, axes.x);
        const vy = readCountRaw(mol.id, axes.y);
        for(let k = 0; k < coef; k++){
          if(vx === 0 && vy === 0) continue;
          const next = { x: current.x + vx, y: current.y + vy, label: mol.label };
          pts.push(next); current = next;
        }
      });
      return pts;
    }

    const ptsR = buildCumulativePathByInstancesOrdered(reactantsOrdered);
    const ptsP = buildCumulativePathByInstancesOrdered(productsOrdered);

    const allPoints = []; ptsR.forEach(p => allPoints.push(p)); ptsP.forEach(p => allPoints.push(p)); allPoints.push({ x: 0, y: 0 });

    const visibleReactants = reactantsOrdered.some(m => {
      const coef = Math.max(0, Math.min(MAX_COEF, Math.floor(Number(q(`.coef[data-mol="${m.id}"]`)?.value || 0))));
      const vx = readCountRaw(m.id, axes.x); const vy = readCountRaw(m.id, axes.y);
      return coef > 0 && (vx !== 0 || vy !== 0);
    });
    const visibleProducts = productsOrdered.some(m => {
      const coef = Math.max(0, Math.min(MAX_COEF, Math.floor(Number(q(`.coef[data-mol="${m.id}"]`)?.value || 0))));
      const vx = readCountRaw(m.id, axes.x); const vy = readCountRaw(m.id, axes.y);
      return coef > 0 && (vx !== 0 || vy !== 0);
    });

    const methodDefEl = document.getElementById('methodDef');
    if(!visibleReactants || !visibleProducts){
      drawFallbackGrid();
      if(mappingNoteEl){
        mappingNoteEl.textContent = "–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–∞–Ω–∏—Ö –¥–ª—è –ø–æ–±—É–¥–æ–≤–∏ –æ–±–æ—Ö —à–ª—è—Ö—ñ–≤: –ø–æ—Ç—Ä—ñ–±–µ–Ω —Ö–æ—á–∞ –± –æ–¥–∏–Ω –≤–∏–¥–∏–º–∏–π —Ä–µ–∞–∫—Ç–∞–Ω—Ç —ñ –æ–¥–∏–Ω –≤–∏–¥–∏–º–∏–π –ø—Ä–æ–¥—É–∫—Ç (–ø–æ—Å—Ç–∞–≤—Ç–µ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç > 0 —Ç–∞/–∞–±–æ –≤–∏–±–µ—Ä—ñ—Ç—å —ñ–Ω—à—ñ –æ—Å—ñ).";
      }
      if(methodDefEl){
        let note = methodDefEl.querySelector('.applicability-note');
        if(!note){
          note = document.createElement('div');
          note.className = 'applicability-note';
          note.style.marginTop = '8px';
          note.style.color = '#8a2';
          methodDefEl.appendChild(note);
        }
        note.textContent = '–ü—Ä–∏–º—ñ—Ç–∫–∞: –º–µ—Ç–æ–¥ –∑–∞—Å—Ç–æ—Å–æ–≤–Ω–∏–π –ª–∏—à–µ –∑–∞ —É–º–æ–≤, –∑–∞–∑–Ω–∞—á–µ–Ω–∏—Ö —É –ø—Ä–∞–≤–∏–ª–∞—Ö (–ø.7).';
      }
      const legend = document.getElementById('vectorLegend');
      if(legend) legend.textContent = "–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –≤–∏–¥–∏–º–∏—Ö –¥–∞–Ω–∏—Ö –¥–ª—è –ø–æ–≤–Ω–æ—ó –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó.";
      saveStateDebounced();
      return;
    } else {
      if(mappingNoteEl) mappingNoteEl.textContent = '';
      const note = methodDefEl && methodDefEl.querySelector('.applicability-note');
      if(note) note.remove();
    }

    // bounding and scaling
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    allPoints.forEach(p => { if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x; if(p.y < minY) minY = p.y; if(p.y > maxY) maxY = p.y; });
    minX = Math.min(minX, 0); minY = Math.min(minY, 0);
    minX = 0; minY = 0;
    if(minX === maxX){ maxX = minX + MIN_AXIS_SPAN; }
    if(minY === maxY){ maxY = minY + MIN_AXIS_SPAN; }
    if((maxX - minX) < MIN_AXIS_SPAN) { maxX = minX + MIN_AXIS_SPAN; }
    if((maxY - minY) < MIN_AXIS_SPAN) { maxY = minY + MIN_AXIS_SPAN; }

    const spanX = maxX - minX; const spanY = maxY - minY;
    const innerSize = svgSize - padding * 2;
    const scaleX = innerSize / (maxX - minX);
    const scaleY = innerSize / (maxY - minY);
    const MAX_SCALE = 120; const MIN_SCALE = 4;
    let scale = Math.min(scaleX, scaleY); scale = Math.min(scale, MAX_SCALE); scale = Math.max(scale, MIN_SCALE);
    function worldToSvg(pt){ const x = padding + (pt.x - minX) * scale; const y = padding + (maxY - pt.y) * scale; return { x, y }; }

    const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
    bg.setAttribute("x","0"); bg.setAttribute("y","0"); bg.setAttribute("width","520"); bg.setAttribute("height","520"); bg.setAttribute("fill","transparent");
    svg.appendChild(bg);

    // grid dots
    const gridGroup = document.createElementNS("http://www.w3.org/2000/svg","g");
    const intMinX = Math.ceil(minX); const intMaxX = Math.floor(maxX);
    const intMinY = Math.ceil(minY); const intMaxY = Math.floor(maxY);
    const totalGridPoints = Math.max(0, (intMaxX - intMinX + 1) * (intMaxY - intMinY + 1));
    const maxDots = 800;
    let sampleX = 1, sampleY = 1;
    if(totalGridPoints > maxDots){
      const factor = Math.sqrt(totalGridPoints / maxDots);
      sampleX = Math.ceil(factor);
      sampleY = Math.ceil(factor);
    }
    for(let xi = intMinX; xi <= intMaxX; xi += sampleX){
      for(let yi = intMinY; yi <= intMaxY; yi += sampleY){
        const s = worldToSvg({ x: xi, y: yi });
        const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
        dot.setAttribute("cx", s.x.toString()); dot.setAttribute("cy", s.y.toString()); dot.setAttribute("r", "1.6"); dot.setAttribute("fill", "#d9eefe");
        gridGroup.appendChild(dot);
      }
    }
    svg.appendChild(gridGroup);

    // axes and ticks
    const originSvg = worldToSvg({ x: 0, y: 0 });
    const axesGroup = document.createElementNS("http://www.w3.org/2000/svg","g");
    const axisX = document.createElementNS("http://www.w3.org/2000/svg","line");
    axisX.setAttribute("x1", (padding).toString()); axisX.setAttribute("y1", originSvg.y.toString());
    axisX.setAttribute("x2", (svgSize - padding).toString()); axisX.setAttribute("y2", originSvg.y.toString());
    axisX.setAttribute("stroke","#e85d5d"); axisX.setAttribute("stroke-width","2");
    axesGroup.appendChild(axisX);
    const axisY = document.createElementNS("http://www.w3.org/2000/svg","line");
    axisY.setAttribute("x1", originSvg.x.toString()); axisY.setAttribute("y1", (padding).toString());
    axisY.setAttribute("x2", originSvg.x.toString()); axisY.setAttribute("y2", (svgSize - padding).toString());
    axisY.setAttribute("stroke","#1e6ed1"); axisY.setAttribute("stroke-width","2");
    axesGroup.appendChild(axisY);

    const targetTicks = 6;
    const stepX = niceStep(spanX, targetTicks);
    const stepY = niceStep(spanY, targetTicks);
    const startX = Math.ceil(minX / stepX) * stepX;
    const startY = Math.ceil(minY / stepY) * stepY;

    for(let val = startX; val <= maxX; val += stepX){
      if(val < minX) continue;
      const s = worldToSvg({ x: val, y: minY });
      const t = document.createElementNS("http://www.w3.org/2000/svg","line");
      t.setAttribute("x1", s.x.toString()); t.setAttribute("y1", (originSvg.y - 4).toString());
      t.setAttribute("x2", s.x.toString()); t.setAttribute("y2", (originSvg.y + 4).toString());
      t.setAttribute("class", "svg-tick");
      svg.appendChild(t);
      const lbl = document.createElementNS("http://www.w3.org/2000/svg","text");
      lbl.setAttribute("x", s.x.toString()); lbl.setAttribute("y", (originSvg.y + 16).toString());
      lbl.setAttribute("text-anchor", "middle");
      lbl.setAttribute("class", "svg-axis-label");
      lbl.textContent = Number.isInteger(val) ? String(val) : Number(val.toFixed(2));
      svg.appendChild(lbl);
    }
    for(let val = startY; val <= maxY; val += stepY){
      if(val < minY) continue;
      const s = worldToSvg({ x: minX, y: val });
      const t = document.createElementNS("http://www.w3.org/2000/svg","line");
      t.setAttribute("x1", (originSvg.x - 4).toString()); t.setAttribute("y1", s.y.toString());
      t.setAttribute("x2", (originSvg.x + 4).toString()); t.setAttribute("y2", s.y.toString());
      t.setAttribute("class", "svg-tick");
      svg.appendChild(t);
      const lbl = document.createElementNS("http://www.w3.org/2000/svg","text");
      lbl.setAttribute("x", (originSvg.x - 8).toString()); lbl.setAttribute("y", (s.y + 4).toString());
      lbl.setAttribute("text-anchor", "end");
      lbl.setAttribute("class", "svg-axis-label");
      lbl.textContent = Number.isInteger(val) ? String(val) : Number(val.toFixed(2));
      svg.appendChild(lbl);
    }

    const axisXLabel = document.createElementNS("http://www.w3.org/2000/svg","text");
    axisXLabel.setAttribute("x", (svgSize - padding + 8).toString());
    axisXLabel.setAttribute("y", (originSvg.y + 4).toString());
    axisXLabel.setAttribute("font-size", "16");
    axisXLabel.setAttribute("font-weight", "700");
    axisXLabel.setAttribute("fill", "#e85d5d");
    axisXLabel.textContent = axes.x;
    axesGroup.appendChild(axisXLabel);

    const axisYLabel = document.createElementNS("http://www.w3.org/2000/svg","text");
    axisYLabel.setAttribute("x", (originSvg.x - 12).toString());
    axisYLabel.setAttribute("y", (padding - 8).toString());
    axisYLabel.setAttribute("font-size", "16");
    axisYLabel.setAttribute("font-weight", "700");
    axisYLabel.setAttribute("fill", "#1e6ed1");
    axisYLabel.textContent = axes.y;
    axesGroup.appendChild(axisYLabel);

    svg.appendChild(axesGroup);

    // label placement helpers
    const placedLabelRects = []; const reservedEndpointRects = [];
    function rectsIntersect(a,b){ return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom); }
    function isInsideCanvas(rect){ return rect.left >= 2 && rect.top >= 2 && rect.right <= svgSize - 2 && rect.bottom <= svgSize - 2; }
    const labelCandidates = [{dx:8, dy:4},{dx:8, dy:-14},{dx:-8, dy:4},{dx:-8, dy:-14},{dx:12, dy:0},{dx:-12, dy:0},{dx:0, dy:12},{dx:0, dy:-18},{dx:16, dy:8},{dx:-16, dy:8}];
    function placeTextAvoidOverlap(txtEl, baseX, baseY){
      let chosenRect = null;
      for(const c of labelCandidates){
        txtEl.setAttribute('x', (baseX + c.dx).toString());
        txtEl.setAttribute('y', (baseY + c.dy).toString());
        const bb = txtEl.getBBox();
        const rect = { left: bb.x, top: bb.y, right: bb.x + bb.width, bottom: bb.y + bb.height };
        if(!isInsideCanvas(rect)) continue;
        let ok = true;
        for(const r of placedLabelRects){ if(rectsIntersect(rect, r)){ ok = false; break; } }
        if(ok){ chosenRect = rect; break; }
      }
      if(!chosenRect){ const c = labelCandidates[labelCandidates.length - 1]; txtEl.setAttribute('x', (baseX + c.dx).toString()); txtEl.setAttribute('y', (baseY + c.dy).toString()); const bb = txtEl.getBBox(); chosenRect = { left: bb.x, top: bb.y, right: bb.x + bb.width, bottom: bb.y + bb.height }; }
      placedLabelRects.push(chosenRect);
    }

    function drawSegmentsWithArrows(points, color, markerId, offsetSign){
      if(!points || points.length < 2) return;
      for(let i = 1; i < points.length; i++){
        const aWorld = points[i-1], bWorld = points[i];
        let a = worldToSvg(aWorld), b = worldToSvg(bWorld);
        const dx = b.x - a.x, dy = b.y - a.y; const segLen = Math.hypot(dx, dy);
        let ax = a.x, ay = a.y, bx = b.x, by = b.y;
        if(segLen > 0.5){ const nx = -dy / segLen; const ny = dx / segLen; const offset = offsetSign * VISUAL_OFFSET_PX; ax += nx * offset; ay += ny * offset; bx += nx * offset; by += ny * offset; }
        else { ax += offsetSign * (VISUAL_OFFSET_PX * 0.5); bx += offsetSign * (VISUAL_OFFSET_PX * 0.5); }
        if(Math.abs(ax - bx) < 0.4 && Math.abs(ay - by) < 0.4) continue;
        const seg = document.createElementNS("http://www.w3.org/2000/svg","path");
        seg.setAttribute("d", `M ${ax} ${ay} L ${bx} ${by}`); seg.setAttribute("fill", "none"); seg.setAttribute("stroke", color);
        seg.setAttribute("stroke-width", "2"); seg.setAttribute("stroke-linecap", "round"); seg.setAttribute("marker-end", `url(#${markerId})`);
        svg.appendChild(seg);

        const midX = (ax + bx) / 2, midY = (ay + by) / 2;
        const dxLabel = bx - ax, dyLabel = by - ay; const lenLabel = Math.hypot(dxLabel, dyLabel) || 1;
        const nxLabel = -dyLabel / lenLabel, nyLabel = dxLabel / lenLabel;
        const LABEL_OFFSET = 22;
        const labelX = midX + nxLabel * LABEL_OFFSET, labelY = midY + nyLabel * LABEL_OFFSET;

        const molLabel = document.createElementNS("http://www.w3.org/2000/svg","text");
        molLabel.setAttribute("font-size", "11"); molLabel.setAttribute("font-weight", "600"); molLabel.setAttribute("fill", color);
        molLabel.setAttribute("text-anchor", "middle"); molLabel.setAttribute("dominant-baseline", "central"); molLabel.textContent = points[i].label;
        svg.appendChild(molLabel);
        placeTextAvoidOverlap(molLabel, labelX, labelY);

        const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
        dot.setAttribute("cx", bx.toString()); dot.setAttribute("cy", by.toString()); dot.setAttribute("r", "1.8"); dot.setAttribute("fill", color);
        svg.appendChild(dot);
      }
      const s0 = worldToSvg(points[0]); let s0x = s0.x, s0y = s0.y;
      if(points.length >= 2){
        const next = worldToSvg(points[1]); const dxn = next.x - s0.x; const dyn = next.y - s0.y; const l = Math.hypot(dxn, dyn);
        if(l > 0.5){ const nx = -dyn / l; const ny = dxn / l; s0x += nx * offsetSign * VISUAL_OFFSET_PX; s0y += ny * offsetSign * VISUAL_OFFSET_PX; }
      } else { s0x += offsetSign * (VISUAL_OFFSET_PX * 0.5); }
      const startCircle = document.createElementNS("http://www.w3.org/2000/svg","circle");
      startCircle.setAttribute("cx", s0x.toString()); startCircle.setAttribute("cy", s0y.toString()); startCircle.setAttribute("r", "3.2"); startCircle.setAttribute("fill", "#fff"); startCircle.setAttribute("stroke", color); startCircle.setAttribute("stroke-width", "1.2");
      svg.appendChild(startCircle);
    }

    const colorR = "#5da0e8"; const colorP = "#e85d5d";
    drawSegmentsWithArrows(ptsR, colorR, "arrowR", -1);
    drawSegmentsWithArrows(ptsP, colorP, "arrowP", +1);

    const endR = ptsR.length ? ptsR[ptsR.length - 1] : { x: 0, y: 0 };
    const endP = ptsP.length ? ptsP[ptsP.length - 1] : { x: 0, y: 0 };

    function buildEquationLeftSide(){
      const parts = [];
      reactants.forEach(m => {
        const coefInput = q(`.coef[data-mol="${m.id}"]`);
        const coef = coefInput ? Math.max(0, Math.min(MAX_COEF, Math.floor(Number(coefInput.value) || 0))) : 0;
        const formula = buildFormulaHTML(m.id);
        if(coef === 0) parts.push(`<span class="muted">${formula}</span>`); else parts.push((coef > 1 ? coef : '') + formula);
      });
      return parts.join(' + ');
    }
    function buildEquationRightSide(){
      const parts = [];
      products.forEach(m => {
        const coefInput = q(`.coef[data-mol="${m.id}"]`);
        const coef = coefInput ? Math.max(0, Math.min(MAX_COEF, Math.floor(Number(coefInput.value) || 0))) : 0;
        const formula = buildFormulaHTML(m.id);
        if(coef === 0) parts.push(`<span class="muted">${formula}</span>`); else parts.push((coef > 1 ? coef : '') + formula);
      });
      return parts.join(' + ');
    }

    function createLabelAt(worldPt, labelText, color){
      const svgPos = worldToSvg(worldPt);
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      const circ = document.createElementNS("http://www.w3.org/2000/svg","circle");
      circ.setAttribute("cx", svgPos.x.toString()); circ.setAttribute("cy", svgPos.y.toString()); circ.setAttribute("r", "4.6"); circ.setAttribute("fill", "#fff"); circ.setAttribute("stroke", color); circ.setAttribute("stroke-width", "2");
      g.appendChild(circ);
      const txt = document.createElementNS("http://www.w3.org/2000/svg","text");
      txt.setAttribute("font-size", "12"); txt.setAttribute("font-weight", "600"); txt.setAttribute("fill", color); txt.textContent = labelText;
      svg.appendChild(g); g.appendChild(txt);

      const endpointLabelCandidates = [{dx:18,dy:-18},{dx:-18,dy:-18},{dx:18,dy:18},{dx:-18,dy:18},{dx:28,dy:0},{dx:-28,dy:0},{dx:0,dy:28},{dx:0,dy:-28}];
      let chosenRect = null;
      for(const c of endpointLabelCandidates){
        txt.setAttribute('x', (svgPos.x + c.dx).toString()); txt.setAttribute('y', (svgPos.y + c.dy).toString()); txt.setAttribute("text-anchor", "middle"); txt.setAttribute("dominant-baseline", "central");
        const bb = txt.getBBox();
        const rect = { left: bb.x - 4, top: bb.y - 4, right: bb.x + bb.width + 4, bottom: bb.y + bb.height + 4 };
        if(!isInsideCanvas(rect)) continue;
        let ok = true;
        for(const r of reservedEndpointRects){ if(rectsIntersect(rect, r)){ ok = false; break; } }
        if(ok){ chosenRect = rect; break; }
      }
      if(!chosenRect){ txt.setAttribute('x', (svgPos.x + 25).toString()); txt.setAttribute('y', (svgPos.y - 20).toString()); const bb = txt.getBBox(); chosenRect = { left: bb.x - 4, top: bb.y - 4, right: bb.x + bb.width + 4, bottom: bb.y + bb.height + 4 }; }
      reservedEndpointRects.push(chosenRect);
    }

    createLabelAt(endR, buildEquationLeftSide(), colorR);
    createLabelAt(endP, buildEquationRightSide(), colorP);

    const eps = 1e-6;
    const balanced = (Math.abs(endR.x - endP.x) <= eps) && (Math.abs(endR.y - endP.y) <= eps);
    const legend = document.getElementById('vectorLegend');
    if(legend){
      const reactFormula = buildGrossFormula(reactantsOrdered);
      const prodFormula = buildGrossFormula(productsOrdered);
      if(balanced){
        legend.innerHTML = `<div style="margin-bottom: 8px;">‚úÖ <b>Balanced</b> ‚Äî –≤–µ–∫—Ç–æ—Ä–Ω—ñ –ø—ñ–¥—Å—É–º–∫–∏ –∑–±—ñ–≥–∞—é—Ç—å—Å—è: (${endR.x}, ${endR.y})</div>
          <div style="display:flex; gap:20px; margin-top:12px; font-size:13px;">
            <div><span style="color:#5da0e8; font-weight:700;">üîµ –†–µ–∞–∫—Ç–∞–Ω—Ç–∏:</span> ${reactFormula}</div>
            <div><span style="color:#e85d5d; font-weight:700;">üî¥ –ü—Ä–æ–¥—É–∫—Ç–∏:</span> ${prodFormula}</div>
          </div>`;
      } else {
        legend.innerHTML = `<div style="margin-bottom: 8px;">‚ùå <b>Not balanced</b> ‚Äî End_R = (${endR.x}, ${endR.y}), End_P = (${endP.x}, ${endP.y})</div>
          <div style="display:flex; gap:20px; margin-top: 12px; font-size:13px;">
            <div><span style="color:#5da0e8; font-weight:700;">üîµ –†–µ–∞–∫—Ç–∞–Ω—Ç–∏:</span> ${reactFormula}</div>
            <div><span style="color:#e85d5d; font-weight:700;">üî¥ –ü—Ä–æ–¥—É–∫—Ç–∏:</span> ${prodFormula}</div>
          </div>`;
      }
    }

    // update mapping note
    let sumR_x = 0, sumR_y = 0, sumP_x = 0, sumP_y = 0;
    reactants.forEach(m => {
      const coef = Math.max(0, Math.min(MAX_COEF, Math.floor(Number(q(`.coef[data-mol="${m.id}"]`)?.value || 0))));
      sumR_x += (function(){ const input = q(`.cell[data-mol="${m.id}"][data-elem="${axes.x}"]`); return input ? Math.max(0, Math.floor(Number(input.value)||0)) : 0; })() * coef;
      sumR_y += (function(){ const input = q(`.cell[data-mol="${m.id}"][data-elem="${axes.y}"]`); return input ? Math.max(0, Math.floor(Number(input.value)||0)) : 0; })() * coef;
    });
    products.forEach(m => {
      const coef = Math.max(0, Math.min(MAX_COEF, Math.floor(Number(q(`.coef[data-mol="${m.id}"]`)?.value || 0))));
      sumP_x += (function(){ const input = q(`.cell[data-mol="${m.id}"][data-elem="${axes.x}"]`); return input ? Math.max(0, Math.floor(Number(input.value)||0)) : 0; })() * coef;
      sumP_y += (function(){ const input = q(`.cell[data-mol="${m.id}"][data-elem="${axes.y}"]`); return input ? Math.max(0, Math.floor(Number(input.value)||0)) : 0; })() * coef;
    });
    const rpProjX = sumR_x - sumP_x; const rpProjY = sumR_y - sumP_y;
    if(mappingNoteEl){
      mappingNoteEl.innerHTML = `<div><b>–ü—Ä–æ—î–∫—Ü—ñ—è (–æ—Å—ñ ${axes.x}, ${axes.y}):</b></div>
        <div>R‚àíP (–∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç—ñ–≤) = (${rpProjX}, ${rpProjY}) = End_R ‚àí End_P (–≥–µ–æ–º–µ—Ç—Ä–∏—á–Ω–æ)</div>
        <div style="color:#665; margin-top:4px;">–ü—Ä–∏–º—ñ—Ç–∫–∞: —É –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó –∫–æ–∂–Ω–∞ –º–æ–ª–µ–∫—É–ª–∞ –∑ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–æ–º k –≤—ñ–¥—Ç–≤–æ—Ä—é—î—Ç—å—Å—è —è–∫ k –æ–∫—Ä–µ–º–∏—Ö —Å–µ–≥–º–µ–Ω—Ç—ñ–≤.</div>`;
    }

    saveStateDebounced();
  } // drawVectors end

  // Build the visible equation (always present)
  function buildEquation(){
    const leftParts = [];
    reactants.forEach(m => {
      const coefInput = q(`.coef[data-mol="${m.id}"]`);
      const coef = coefInput ? Math.max(0, Math.min(MAX_COEF, Math.floor(Number(coefInput.value) || 0))) : 0;
      const formula = buildFormulaHTML(m.id);
      if(coef === 0) leftParts.push(`<span class="muted">${formula}</span>`); else leftParts.push((coef>1?coef:'') + formula);
    });
    const rightParts = [];
    products.forEach(m => {
      const coefInput = q(`.coef[data-mol="${m.id}"]`);
      const coef = coefInput ? Math.max(0, Math.min(MAX_COEF, Math.floor(Number(coefInput.value) || 0))) : 0;
      const formula = buildFormulaHTML(m.id);
      if(coef === 0) rightParts.push(`<span class="muted">${formula}</span>`); else rightParts.push((coef>1?coef:'') + formula);
    });
    const joiner = ' <span style="color:#666; font-weight:600">+</span> ';
    const leftHTML = leftParts.length ? leftParts.join(joiner) : '<span style="color:#999">‚Äî</span>';
    const rightHTML = rightParts.length ? rightParts.join(joiner) : '<span style="color:#999">‚Äî</span>';
    document.getElementById("equation").innerHTML = `<div class="formula-part">${leftHTML}</div><div style="font-weight:700; padding:0 8px"> = </div><div class="formula-part">${rightHTML}</div>`;
  }

  // Event wiring
  function onChangeHandler(){
    qAll('.coef').forEach(coefEl => { coefEl.value = Math.max(0, Math.min(MAX_COEF, Math.floor(Number(coefEl.value) || 0))); });
    [...reactants, ...products].forEach(m => { const nameEl = document.getElementById(`name_${m.id}`); if(nameEl) nameEl.innerHTML = buildFormulaHTML(m.id); });
    buildEquation(); updateDifference(); drawVectors(); saveStateDebounced();
  }

  // attach events for existing inputs
  function attachInputHandlers(){
    qAll("input.num").forEach(inp => inp.removeEventListener("input", onChangeHandler));
    qAll("input.num").forEach(inp => inp.addEventListener("input", onChangeHandler));
    qAll(".coef").forEach(inp => { inp.removeEventListener("input", onChangeHandler); inp.addEventListener("input", onChangeHandler); });
  }
  attachInputHandlers();

  // initial behaviour: ensure coefs set
  [...reactants, ...products].forEach(m => {
    const coef = document.querySelector(`.coef[data-mol="${m.id}"]`);
    const any = elements.some(el => { const cell = document.querySelector(`.cell[data-mol="${m.id}"][data-elem="${el}"]`); return cell && Number(cell.value) > 0; });
    if(coef) coef.value = any ? (coef.value || 1) : (coef.value || 0);
  });

  // load saved state
  const saved = loadState();
  if(saved) {
    restoreState(saved);
    attachInputHandlers();
  }

  // wire selects and order change
  q('#orderR')?.addEventListener('change', () => drawVectors());
  q('#orderP')?.addEventListener('change', () => drawVectors());
  window.addEventListener('resize', () => drawVectors());
  window.addEventListener('beforeunload', saveState);

  // --- Parser integration: parse & load a single balanced equation into the table ---
  async function parseAndLoadEquation(){
    const txt = (document.getElementById('parsedInput')||{value:""}).value.trim();
    if(!txt){ alert("–í—Å—Ç–∞–≤—Ç–µ –∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–µ —Ä—ñ–≤–Ω—è–Ω–Ω—è —É –ø–æ–ª–µ."); return; }
    if(typeof Elems_List !== 'function' || typeof Equation_Split !== 'function'){
      alert("–ü–∞—Ä—Å–µ—Ä (chem_parser.js) –Ω–µ –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ ‚Äî –∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ chem_parser.js —É —Å—Ç–æ—Ä—ñ–Ω–∫—É.");
      return;
    }

    // Parse elements and sides using provided parser
    let elemsArr, eqSplit;
    try { elemsArr = Elems_List(txt); } catch(e){ console.error(e); alert("–ü–æ–º–∏–ª–∫–∞ Elems_List"); return; }
    try { eqSplit = Equation_Split(txt); } catch(e){ console.error(e); alert("–ü–æ–º–∏–ª–∫–∞ Equation_Split"); return; }

    // Build elements list
    const parsedElements = [];
    for(let i=1;i<elemsArr.length;i++) parsedElements.push(elemsArr[i]);

    // Build reactant/product molecule descriptors
    const reagR = eqSplit[1], reagP = eqSplit[2];
    function mkMolList(arr, sidePrefix){
      const list = [];
      for(let i=1;i<arr.length;i++){
        const coef = arr[i][0];
        const arrFormula = arr[i][1];
        const origLabel = (Array.isArray(arrFormula) && arrFormula[0] && arrFormula[0][0]) ? arrFormula[0][0] : ("mol"+i);
        const safeIdBase = origLabel.toString().toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_+|_+$/g,'') || (sidePrefix+i);
        let id = safeIdBase; let idx = 1;
        while(list.some(x => x.id === id)) { id = safeIdBase + "_" + (idx++); }
        list.push({ id: id, label: origLabel.toString(), coef: Math.max(0, Math.floor(Number(coef)||0)), formulaArray: arrFormula });
      }
      return list;
    }
    const parsedReactants = mkMolList(reagR, "r");
    const parsedProducts  = mkMolList(reagP, "p");

    // Build defaultIndexMap from parser info
    const newDefaultIndexMap = {};
    function formulaArrToMap(formulaArr){
      const m = {};
      if(!Array.isArray(formulaArr)) return m;
      for(let j=1;j<formulaArr.length;j++){
        const p = formulaArr[j];
        if(!p) continue;
        const el = p[0];
        const val = Number(p[1]) || 0;
        m[el] = (m[el] || 0) + val;
      }
      return m;
    }
    parsedReactants.forEach(m => newDefaultIndexMap[m.id] = formulaArrToMap(m.formulaArray));
    parsedProducts.forEach(m => newDefaultIndexMap[m.id] = formulaArrToMap(m.formulaArray));

    // Replace UI lists and rebuild table
    reactants = parsedReactants.map(m => ({ id: m.id, label: m.label }));
    products  = parsedProducts.map(m => ({ id: m.id, label: m.label }));
    defaultIndexMap = newDefaultIndexMap;
    // Replace elements if parser returned some
    if(parsedElements.length) {
      elements.length = 0;
      parsedElements.forEach(e => elements.push(e));
    }

    buildMoleculeHeader();
    buildElementsTable();
    attachInputHandlers();

    // fill coefficients from parsed data (if non-zero), otherwise keep existing
    parsedReactants.forEach(m => { const coefEl = q(`.coef[data-mol="${m.id}"]`); if(coefEl) coefEl.value = m.coef || 1; });
    parsedProducts.forEach(m => { const coefEl = q(`.coef[data-mol="${m.id}"]`); if(coefEl) coefEl.value = m.coef || 1; });

    // populate inputs with defaultIndexMap
    qAll('.cell').forEach(inp => {
      const molId = inp.dataset.mol;
      const el = inp.dataset.elem;
      const val = (defaultIndexMap[molId] && defaultIndexMap[molId][el]) ? defaultIndexMap[molId][el] : 0;
      inp.value = val;
    });

    // refresh UI
    buildEquation();
    updateDifference();
    drawVectors();
    saveStateDebounced();
  }

  document.getElementById('loadParsedBtn')?.addEventListener('click', parseAndLoadEquation);
  document.getElementById('clearParsedBtn')?.addEventListener('click', () => { document.getElementById('parsedInput').value = ""; });

  // final initial render
  buildEquation();
  updateDifference();
  drawVectors();
});
</script>

</body>
</html>