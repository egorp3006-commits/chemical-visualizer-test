<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Інтерактивна таблиця — баланс реакції + вектори</title>

<style>
  :root{ --accent:#2a9df4; --pos:#1e6ed1; --neg:#d13b3b; --border:#9aa;}
  body{background:#f6f9fc; margin:0; padding:0; font-family:Arial, sans-serif;}
  .chem-wrap{max-width:1200px; margin:24px auto; background:#fff; padding:16px; border-radius:12px; box-shadow:0 2px 6px rgba(0,0,0,0.08);}
  .title{text-align:center; font-weight:700; margin-bottom:6px; font-size:20px;}
  .eq{ text-align:center; margin-bottom:12px; font-size:18px;}
  .formula-box{display:flex; gap:8px; justify-content:center; flex-wrap:wrap; align-items:center; margin-bottom:8px;}
  .formula-part{display:inline-flex; align-items:center; gap:6px; font-weight:600;}

  .controls-row{display:flex; gap:12px; align-items:center; justify-content:center; margin-bottom:12px; flex-wrap:wrap;}

  .layout{display:grid; grid-template-columns: 1fr 480px; gap:16px; align-items:start;}
  /* On small screens stack */
  @media (max-width:1100px){ .layout{grid-template-columns:1fr;} }

  table.chem{border-collapse:collapse; width:100%;}
  table.chem th, table.chem td{border:1px solid var(--border); padding:6px; text-align:center; min-width:46px; background:#fff; vertical-align:middle;}
  table.chem th{background:#e6f0fb; font-weight:700;}
  .elem-cell{background:#fafafa; font-weight:600;}
  input.num{width:100%; box-sizing:border-box; border:0; text-align:center; font-size:14px; padding:4px; background:transparent;}
  input.num:focus{outline:1px solid var(--accent); background:#eef7ff;}
  .coef{width:48px; box-sizing:border-box; padding:4px; text-align:center; border-radius:6px; border:1px solid #d7eafb; background:#f8fbff;}
  .mol-header{display:flex; flex-direction:column; gap:6px; align-items:center; justify-content:center;}
  .mol-name{font-weight:700; font-size:14px;}
  .mol-coef-label{font-size:11px; color:#555;}
  .rp-cell{min-height:36px; min-width:64px; display:flex; align-items:center; justify-content:center; background:#fff; transition:color 0.15s, background 0.15s;}
  .rp-zero{color:#333;}
  .rp-pos{color:var(--pos); font-weight:700;}
  .rp-neg{color:var(--neg); font-weight:700;}
  .note{font-size:13px; color:#555; text-align:center; margin-top:8px;}
  .mol-fallback{opacity:0.7; font-style:italic;}
  /* Забороняємо перенесення для заголовка R-P, щоб бути в один рядок */
  .rp-header{ white-space:nowrap; vertical-align:middle; }

  /* vector panel */
  .vector-panel{background:#fff; border:1px solid #e2eefc; border-radius:10px; padding:8px;}
  .vector-title{font-weight:700; font-size:15px; margin-bottom:8px; text-align:center;}
  .vector-svg{width:100%; height:auto; display:block; background:linear-gradient(180deg,#fbfeff,#f7fbff); border-radius:8px; border:1px solid #e6f7ff;}
  .vector-legend{font-size:13px; margin-top:8px; color:#444; text-align:center;}
  .axis-selectors{display:flex; gap:8px; justify-content:center; align-items:center; margin-bottom:8px; flex-wrap:wrap;}
  .axis-selectors label{font-size:13px; color:#333;}

  /* small screens */
  @media (max-width:880px){
    .coef{width:40px;}
    table.chem th, table.chem td{font-size:13px; padding:6px;}
    .formula-box{font-size:15px;}
  }
</style>
</head>
<body>

<div class="chem-wrap">
  <div class="title">Інтерактивна таблиця — баланс реакції + вектори</div>

  <div class="eq" aria-live="polite">
    <div class="formula-box" id="equation">
      <!-- динамічне рівняння -->
    </div>
    <div style="font-size:13px; color:#444;">(Реагенти зліва — Продукти справа)</div>
  </div>

  <div class="controls-row">
    <div style="font-size:13px; color:#444;">Оберіть осі для векторів (X, Y):</div>
    <div class="axis-selectors" id="axisSelectors">
      <!-- радіо селектори з'являться тут -->
    </div>
  </div>

  <div class="layout">
    <!-- Ліва: таблиця -->
    <div>
      <!-- Єдина таблиця, щоб вирівнювання рядків було точним -->
      <table class="chem" id="mainTable" aria-label="Таблиця елементів і молекул">
        <!-- Групова шапка -->
        <thead>
          <tr>
            <th rowspan="2">Елемент</th>
            <th colspan="1">X</th>
            <th colspan="1">Y</th>
            <th colspan="3">Реагенти</th>
            <th class="rp-header" rowspan="2">R − P</th>
            <th colspan="5">Продукти</th>
          </tr>
          <tr id="moleculeHeaders">
            <!-- тут будуть заголовки молекул (ім'я + input коефіцієнта) -->
          </tr>
        </thead>

        <tbody id="elementsBody">
          <!-- рядки елементів (заповнені скриптом) -->
        </tbody>
      </table>

      <div class="note">Змінюй числа індексів або коефіцієнти — рівняння, різниця (R − P) та вектори оновлюються автоматично. Якщо коефіцієнт 0 — молекулу не показуємо; 1 — цифру 1 не показуємо.</div>
    </div>

    <!-- Права: панель векторів -->
    <div class="vector-panel" aria-label="Панель векторів">
      <div class="vector-title">Координатна сіточка 0…10 — вектори молекул</div>
      <svg id="vectorSvg" class="vector-svg" viewBox="0 0 520 520" role="img" aria-label="Координатна сіточка"></svg>
      <div class="vector-legend" id="vectorLegend">Координати: (X, Y) — значення кількостей елементів по вибраних осях. Кількість маркерів для молекули = її коефіцієнт.</div>
    </div>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  // Налаштування: список елементів і молекул
  const elements = ["H","C","O","N","P","S","F","Na","Ca"];
  const reactants = [
    {id:"h2o", label:"H2O"},
    {id:"co2", label:"CO2"},
    {id:"o2",  label:"O2"}
  ];
  const products = [
    {id:"h2",   label:"H2"},
    {id:"o3",   label:"O3"},
    {id:"h2co3",label:"H2CO3"},
    {id:"n2",   label:"N2"},
    {id:"nh3",  label:"NH3"}
  ];

  // --- Побудова заголовків молекул + коефіцієнтів
  const headerRow = document.getElementById("moleculeHeaders");
  function makeMolHeaderCell(mol){
    const th = document.createElement("th");
    th.innerHTML = `
      <div class="mol-header">
        <div class="mol-name" data-mol="${mol.id}" id="name_${mol.id}">${mol.label}</div>
        <div class="mol-coef-label">
          <input class="coef" aria-label="Коефіцієнт ${mol.label}" data-mol="${mol.id}" type="number" min="0" step="1" value="1">
        </div>
      </div>`;
    return th;
  }
  reactants.forEach(m => headerRow.appendChild(makeMolHeaderCell(m)));
  products.forEach(m => headerRow.appendChild(makeMolHeaderCell(m)));

  // --- Побудова тіла таблиці (рядок на кожен елемент) з колонками X та Y (радіо)
  const body = document.getElementById("elementsBody");
  elements.forEach((elem, idx) => {
    const tr = document.createElement("tr");

    // Елемент
    const tdElem = document.createElement("td");
    tdElem.className = "elem-cell";
    tdElem.textContent = elem;
    tr.appendChild(tdElem);

    // X radio
    const tdX = document.createElement("td");
    tdX.innerHTML = `<input type="radio" name="axis-x" aria-label="Обрати ${elem} як X" value="${elem}" ${idx===0 ? "checked" : ""}>`;
    tr.appendChild(tdX);

    // Y radio
    const tdY = document.createElement("td");
    tdY.innerHTML = `<input type="radio" name="axis-y" aria-label="Обрати ${elem} як Y" value="${elem}" ${idx===1 ? "checked" : ""}>`;
    tr.appendChild(tdY);

    // для кожного реагента — input індексів
    reactants.forEach(m => {
      const td = document.createElement("td");
      td.innerHTML = `<input class="num cell left" data-mol="${m.id}" data-elem="${elem}" type="number" value="${defaultIndex(m.id, elem)}" min="0" step="1" aria-label="Індекс елемента ${elem} в молекулі ${m.label}">`;
      tr.appendChild(td);
    });

    // R-P cell
    const rpTd = document.createElement("td");
    rpTd.className = "rp-cell";
    rpTd.id = `rp_${elem}`;
    rpTd.textContent = "0";
    tr.appendChild(rpTd);

    // для кожного продукту — input індексів
    products.forEach(m => {
      const td = document.createElement("td");
      td.innerHTML = `<input class="num cell right" data-mol="${m.id}" data-elem="${elem}" type="number" value="${defaultIndex(m.id, elem)}" min="0" step="1" aria-label="Індекс елемента ${elem} в молекулі ${m.label}">`;
      tr.appendChild(td);
    });

    body.appendChild(tr);
  });

  // Значення за замовчуванням (від вашої початкової таблиці)
  function defaultIndex(mol, elem){
    const map = {
      h2o: {H:2,O:1},
      co2: {C:1,O:2},
      o2:  {O:2},
      h2:  {H:2},
      o3:  {O:3},
      h2co3:{H:2,C:1,O:3},
      n2:  {N:2},
      nh3: {N:1,H:3}
    };
    return (map[mol] && map[mol][elem]) ? map[mol][elem] : 0;
  }

  // Утиліти
  function qAll(selector){ return Array.from(document.querySelectorAll(selector)); }
  function q(selector){ return document.querySelector(selector); }

  // Побудова формули молекули як HTML (індекси як звичайні цифри, але тут можна змінити)
  function buildFormulaHTML(molId){
    const parts = [];
    elements.forEach(el => {
      const input = document.querySelector(`.cell[data-mol="${molId}"][data-elem="${el}"]`);
      const val = input ? Number(input.value) || 0 : 0;
      if(val > 0){
        // залишаємо цифру в звичайному розмірі (як у вашому оригіналі)
        parts.push(el + (val > 1 ? `${val}` : ""));
      }
    });
    if(parts.length === 0) return `<span class="mol-fallback">${molId}</span>`;
    return parts.join("");
  }

  // Побудова рівняння у верхній частині (реагенти = продукти)
  function buildEquation(){
    const leftParts = [];
    reactants.forEach(m => {
      const coefInput = document.querySelector(`.coef[data-mol="${m.id}"]`);
      const coef = coefInput ? Math.max(0, Math.floor(Number(coefInput.value) || 0)) : 0;
      if(coef === 0) return;
      const formula = buildFormulaHTML(m.id);
      const prefix = coef > 1 ? `${coef}` : "";
      leftParts.push(prefix + formula);
    });
    const rightParts = [];
    products.forEach(m => {
      const coefInput = document.querySelector(`.coef[data-mol="${m.id}"]`);
      const coef = coefInput ? Math.max(0, Math.floor(Number(coefInput.value) || 0)) : 0;
      if(coef === 0) return;
      const formula = buildFormulaHTML(m.id);
      const prefix = coef > 1 ? `${coef}` : "";
      rightParts.push(prefix + formula);
    });

    const joiner = ' <span style="color:#666; font-weight:600">+</span> ';
    const leftHTML = leftParts.length ? leftParts.join(joiner) : '<span style="color:#999">—</span>';
    const rightHTML = rightParts.length ? rightParts.join(joiner) : '<span style="color:#999">—</span>';

    const eqBox = document.getElementById("equation");
    eqBox.innerHTML = `<div class="formula-part">${leftHTML}</div><div style="font-weight:700; padding:0 8px"> = </div><div class="formula-part">${rightHTML}</div>`;
  }

  // Обчислення різниці R - P по кожному елементу і оновлення стилю
  function updateDifference(){
    elements.forEach(elem => {
      let leftSum = 0;
      qAll(`.left[data-elem="${elem}"]`).forEach(input => leftSum += Number(input.value) || 0);
      let rightSum = 0;
      qAll(`.right[data-elem="${elem}"]`).forEach(input => rightSum += Number(input.value) || 0);
      const diff = leftSum - rightSum;
      const cell = document.getElementById(`rp_${elem}`);
      if(!cell) return;
      cell.textContent = diff;
      cell.classList.remove("rp-pos","rp-neg","rp-zero");
      if(diff > 0) cell.classList.add("rp-pos");
      else if(diff < 0) cell.classList.add("rp-neg");
      else cell.classList.add("rp-zero");
    });
  }

  // --- Вектори: побудова панелі і відмалювання в SVG
  const svg = document.getElementById("vectorSvg");
  const svgSize = 520; // viewBox is 0..520
  const padding = 40; // padding inside svg for labels
  const coordMin = 0;
  const coordMax = 10; // сітка 0..10
  const gridCount = coordMax - coordMin + 1;

  // Малюємо фон сіточки та підписи (статично, оновлюються при ресайзі)
  function drawGrid(){
    // Очистити
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    // фон
    const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
    bg.setAttribute("x","0"); bg.setAttribute("y","0"); bg.setAttribute("width","520"); bg.setAttribute("height","520");
    bg.setAttribute("fill","transparent");
    svg.appendChild(bg);

    const innerSize = svgSize - padding*2;
    const step = innerSize / (coordMax - coordMin);

    // осі
    const axis = document.createElementNS("http://www.w3.org/2000/svg","g");
    axis.setAttribute("stroke","#bcd");
    axis.setAttribute("stroke-width","1");
    svg.appendChild(axis);

    // вертикальні та горизонтальні лінії (тонкі), але ми зробимо крапкову сіточку
    for(let i=0;i<gridCount;i++){
      const x = padding + i*step;
      for(let j=0;j<gridCount;j++){
        const y = padding + (gridCount-1-j)*step; // invert y for svg
        const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
        dot.setAttribute("cx", x.toString());
        dot.setAttribute("cy", y.toString());
        dot.setAttribute("r", "2");
        dot.setAttribute("fill", "#d9eefe");
        svg.appendChild(dot);
      }
      // підписи по осі X
      const tx = document.createElementNS("http://www.w3.org/2000/svg","text");
      tx.setAttribute("x", (padding + i*step).toString());
      tx.setAttribute("y", (svgSize - 8).toString());
      tx.setAttribute("font-size", "10");
      tx.setAttribute("fill", "#436");
      tx.setAttribute("text-anchor","middle");
      tx.textContent = String(coordMin + i);
      svg.appendChild(tx);

      // підписи по осі Y (left side)
      const ty = document.createElementNS("http://www.w3.org/2000/svg","text");
      ty.setAttribute("x", "12");
      ty.setAttribute("y", (padding + (gridCount-1-i)*step + 3).toString());
      ty.setAttribute("font-size", "10");
      ty.setAttribute("fill", "#436");
      ty.setAttribute("text-anchor","start");
      ty.textContent = String(coordMin + i);
      svg.appendChild(ty);
    }

    // осі X та Y жирніші
    const axisX = document.createElementNS("http://www.w3.org/2000/svg","line");
    axisX.setAttribute("x1", padding.toString());
    axisX.setAttribute("y1", (svgSize - padding).toString());
    axisX.setAttribute("x2", (svgSize - padding).toString());
    axisX.setAttribute("y2", (svgSize - padding).toString());
    axisX.setAttribute("stroke","#79a9d9");
    axisX.setAttribute("stroke-width","1.5");
    svg.appendChild(axisX);

    const axisY = document.createElementNS("http://www.w3.org/2000/svg","line");
    axisY.setAttribute("x1", padding.toString());
    axisY.setAttribute("y1", padding.toString());
    axisY.setAttribute("x2", padding.toString());
    axisY.setAttribute("y2", (svgSize - padding).toString());
    axisY.setAttribute("stroke","#79a9d9");
    axisY.setAttribute("stroke-width","1.5");
    svg.appendChild(axisY);

    // Axis labels (we'll update texts later with chosen elements)
    const labelX = document.createElementNS("http://www.w3.org/2000/svg","text");
    labelX.setAttribute("id","svgLabelX");
    labelX.setAttribute("x",(svgSize/2).toString());
    labelX.setAttribute("y",(svgSize - 6).toString());
    labelX.setAttribute("font-size","12");
    labelX.setAttribute("fill","#234");
    labelX.setAttribute("text-anchor","middle");
    svg.appendChild(labelX);

    const labelY = document.createElementNS("http://www.w3.org/2000/svg","text");
    labelY.setAttribute("id","svgLabelY");
    labelY.setAttribute("x","12");
    labelY.setAttribute("y",(padding - 12).toString());
    labelY.setAttribute("font-size","12");
    labelY.setAttribute("fill","#234");
    labelY.setAttribute("text-anchor","start");
    svg.appendChild(labelY);
  }

  // Отримати поточні вибрані осі
  function getSelectedAxes(){
    const x = q('input[name="axis-x"]:checked')?.value || elements[0];
    const y = q('input[name="axis-y"]:checked')?.value || elements[1] || elements[0];
    return { x, y };
  }

  // Відмалювати вектори: для кожної молекули беремо значення обраних елементів і малюємо стільки маркерів, скільки коефіцієнт
  function drawVectors(){
    // Перемалюємо базову сіточку
    drawGrid();

    const innerSize = svgSize - padding*2;
    const step = innerSize / (coordMax - coordMin);
    const axes = getSelectedAxes();
    const labelX = svg.querySelector('#svgLabelX');
    const labelY = svg.querySelector('#svgLabelY');
    if(labelX) labelX.textContent = `X: ${axes.x}`;
    if(labelY) labelY.textContent = `Y: ${axes.y}`;

    // group for vectors
    const grp = document.createElementNS("http://www.w3.org/2000/svg","g");
    grp.setAttribute("id","vectorsGroup");
    svg.appendChild(grp);

    // color palette for molecules
    const palette = ["#e85d5d","#5da0e8","#5de89a","#e8c95d","#b35de8","#5de0e8","#e85dc4","#8fbf5d","#5d7fe8","#d1863a"];
    const allMols = [...reactants, ...products];

    allMols.forEach((mol, mi) => {
      const coefInput = q(`.coef[data-mol="${mol.id}"]`);
      const coef = coefInput ? Math.max(0, Math.floor(Number(coefInput.value) || 0)) : 0;
      if(coef <= 0) return; // не показуємо молекулу якщо 0

      // координати по вибраних елементах (кількість атомів)
      const xCountInput = q(`.cell[data-mol="${mol.id}"][data-elem="${axes.x}"]`);
      const yCountInput = q(`.cell[data-mol="${mol.id}"][data-elem="${axes.y}"]`);
      const xCount = xCountInput ? Math.max(0, Math.floor(Number(xCountInput.value) || 0)) : 0;
      const yCount = yCountInput ? Math.max(0, Math.floor(Number(yCountInput.value) || 0)) : 0;

      // Якщо обидва нулі, то можна показати faded label поруч (або пропустити)
      if(xCount===0 && yCount===0) return;

      // Кольори
      const color = palette[mi % palette.length];

      // Розміщення N повторюваних маркерів (coef) — трохи зсунути кожен, щоб бачити multiplicity
      for(let k=0;k<coef;k++){
        // невеликий jitter для розділення при множинності
        const jitter = (k - (coef-1)/2) * 4; // spread
        // обмежимо координати, щоб вони вкладалися в від 0 до coordMax
        const xVal = Math.min(coordMax, Math.max(coordMin, xCount));
        const yVal = Math.min(coordMax, Math.max(coordMin, yCount));
        const cx = padding + xVal * step + jitter;
        const cy = padding + (coordMax - yVal) * step + jitter;

        const marker = document.createElementNS("http://www.w3.org/2000/svg","circle");
        marker.setAttribute("cx", cx.toString());
        marker.setAttribute("cy", cy.toString());
        marker.setAttribute("r", "7");
        marker.setAttribute("fill", color);
        marker.setAttribute("fill-opacity", "0.85");
        marker.setAttribute("stroke","#fff");
        marker.setAttribute("stroke-width","1.2");
        marker.setAttribute("data-mol", mol.id);
        marker.setAttribute("title", `${mol.label} → (${xCount}, ${yCount})`);
        grp.appendChild(marker);

        // label with molecule id (small)
        const txt = document.createElementNS("http://www.w3.org/2000/svg","text");
        txt.setAttribute("x", (cx+10).toString());
        txt.setAttribute("y", (cy+4).toString());
        txt.setAttribute("font-size","10");
        txt.setAttribute("fill","#214");
        txt.textContent = `${mol.label}${coef>1?`×${coef}`:""}`;
        grp.appendChild(txt);
        // only one label per molecule (break) to avoid overlapping labels for duplicates
        break;
      }
    });

    // Якщо жодного вектора — покажемо підказку у центрі
    const anyVectors = svg.querySelectorAll('#vectorsGroup circle').length > 0;
    if(!anyVectors){
      const hint = document.createElementNS("http://www.w3.org/2000/svg","text");
      hint.setAttribute("x",(svgSize/2).toString());
      hint.setAttribute("y",(svgSize/2).toString());
      hint.setAttribute("font-size","13");
      hint.setAttribute("fill","#789");
      hint.setAttribute("text-anchor","middle");
      hint.textContent = "Немає видимих векторів (поставте коефіцієнт > 0 або виберіть інші осі)";
      svg.appendChild(hint);
    }
  }

  // Побудова селекторів осей (радіо колекція для вибору осей)
  const axisSelectors = document.getElementById("axisSelectors");
  function buildAxisSelectors(){
    axisSelectors.innerHTML = "";
    // X selector group (labels + radios)
    const xGroup = document.createElement("div");
    xGroup.style.display = "flex";
    xGroup.style.gap = "8px";
    xGroup.style.flexWrap = "wrap";
    xGroup.style.alignItems = "center";

    const xLabel = document.createElement("span");
    xLabel.textContent = "X:";
    xLabel.style.fontWeight = "600";
    xLabel.style.marginRight = "4px";
    xGroup.appendChild(xLabel);

    elements.forEach((el, idx) => {
      const lab = document.createElement("label");
      lab.style.display = "inline-flex";
      lab.style.alignItems = "center";
      lab.style.gap = "4px";
      const r = document.createElement("input");
      r.type = "radio";
      r.name = "axis-x-controls";
      r.value = el;
      r.checked = (idx === 0);
      r.addEventListener("change", () => {
        // при зміні керуючого селектора синхронізуємо таблицю radio
        const tableRadio = q(`input[name="axis-x"][value="${el}"]`);
        if(tableRadio) tableRadio.checked = true;
        drawVectors();
      });
      lab.appendChild(r);
      const span = document.createElement("span");
      span.textContent = el;
      span.style.fontSize = "13px";
      lab.appendChild(span);
      xGroup.appendChild(lab);
    });

    // Y group
    const yGroup = document.createElement("div");
    yGroup.style.display = "flex";
    yGroup.style.gap = "8px";
    yGroup.style.flexWrap = "wrap";
    yGroup.style.alignItems = "center";

    const yLabel = document.createElement("span");
    yLabel.textContent = "Y:";
    yLabel.style.fontWeight = "600";
    yLabel.style.marginRight = "4px";
    yGroup.appendChild(yLabel);

    elements.forEach((el, idx) => {
      const lab = document.createElement("label");
      lab.style.display = "inline-flex";
      lab.style.alignItems = "center";
      lab.style.gap = "4px";
      const r = document.createElement("input");
      r.type = "radio";
      r.name = "axis-y-controls";
      r.value = el;
      r.checked = (idx === 1);
      r.addEventListener("change", () => {
        const tableRadio = q(`input[name="axis-y"][value="${el}"]`);
        if(tableRadio) tableRadio.checked = true;
        drawVectors();
      });
      lab.appendChild(r);
      const span = document.createElement("span");
      span.textContent = el;
      span.style.fontSize = "13px";
      lab.appendChild(span);
      yGroup.appendChild(lab);
    });

    axisSelectors.appendChild(xGroup);
    axisSelectors.appendChild(yGroup);

    // також прив'язуємо події до радіо всередині таблиці (щоб зміни там синхронізували контролери)
    qAll('input[name="axis-x"]').forEach(r => r.addEventListener('change', () => {
      // синхронізуємо контролер:
      const val = r.value;
      const control = document.querySelector(`input[name="axis-x-controls"][value="${val}"]`);
      if(control) control.checked = true;
      drawVectors();
    }));
    qAll('input[name="axis-y"]').forEach(r => r.addEventListener('change', () => {
      const val = r.value;
      const control = document.querySelector(`input[name="axis-y-controls"][value="${val}"]`);
      if(control) control.checked = true;
      drawVectors();
    }));
  }

  // --- Загальний onChange: оновлює формули, різницю та вектори
  function onChangeHandler(){
    // Оновлюємо назви молекул над заголовками (щоб індекси відображались одразу)
    [...reactants, ...products].forEach(m => {
      const nameEl = document.getElementById(`name_${m.id}`);
      if(nameEl) nameEl.innerHTML = buildFormulaHTML(m.id);
    });

    buildEquation();
    updateDifference();
    drawVectors();
  }

  // --- Підвіска подій (один раз)
  // input для індексів
  qAll("input.num").forEach(inp => inp.addEventListener("input", onChangeHandler));
  // input для коефіцієнтів; обмежимо цілі числа
  qAll("input.coef").forEach(inp => {
    inp.addEventListener("input", () => {
      // округляємо до цілого
      inp.value = Math.max(0, Math.floor(Number(inp.value) || 0));
      onChangeHandler();
    });
  });

  // Побудова селекторів осей і ініціалізувати
  buildAxisSelectors();

  // Встановимо початкові коефіцієнти: якщо формула порожня — 0, інакше 1
  [...reactants, ...products].forEach(m => {
    const coef = document.querySelector(`.coef[data-mol="${m.id}"]`);
    const any = elements.some(el => {
      const cell = document.querySelector(`.cell[data-mol="${m.id}"][data-elem="${el}"]`);
      return cell && Number(cell.value) > 0;
    });
    if(coef) coef.value = any ? (coef.value || 1) : 0;
  });

  // Перший малюнок
  onChangeHandler();

  // Обробка ресайзу (SVG responsive)
  window.addEventListener('resize', () => {
    drawVectors();
  });

});
</script>

</body>
</html>